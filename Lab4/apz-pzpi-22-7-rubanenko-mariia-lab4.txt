Міністерство освіти і науки України
Харківський національний  університет радіоелектроніки


Кафедра програмної інженерії 



Лабораторна робота №4
 з дисципліни: «Архітектура програмного забезпечення»
Тема: «Розробка програмної архітектури та створення і відлагодження програмного коду програмного застосунку мобільного пристрою для програмної системи»





Виконала
ст. гр. ПЗПІ-22-7
Рубаненко Марія Сергіївна
03 травня 2025 р.
Перевірив
ст. викл. Сокорчук І. П.





Харків 2025
1 ІСТОРІЯ ЗМІН

Таблиця 1.1 відображає зміни, внесені до документа.
Таблиця 1.1 - Історія змін
№	Дата	Версія звіту	Опис змін та виправлень
1	03.05.2025	0.1	Розділ «Історія змін» було додано до документа
2	03.05.2025	0.1	Розділ «Завдання до лабораторної роботи» було додано до документа
3	03.05.2025	0.1	Розділ «Опис виконаної роботи» було додано до документа
4	03.05.2025	0.1	Розділ «Висновки» було додано до документа
5	03.05.2025	0.1	У документ включено «Додаток А» з посиланням на відеоролик
6	03.05.2025	0.1	У документ включено «Додаток Б» 














2 ЗАВДАННЯ


У рамках лабораторної роботи необхідно проаналізувати та описати архітектуру мобільного застосунку розроблюваної програмної системи. Потрібно визначити використовувані програмні технології, компоненти, з яких складається мобільний застосунок, а також функціональні можливості, що реалізовані в цій частині системи. Особливу увагу слід приділити опису реалізованої бізнес-логіки, засобів захисту даних, взаємодії мобільного застосунку з іншими модулями програмної системи, а також підтримці інтерналізації та локалізації. 
До звіту потрібно включити UML-діаграму прецедентів (Use Case Diagram) та UML-діаграму компонент (Component Diagram). Крім того, слід побудувати не менше двох UML-діаграм на вибір із наступного переліку: діаграма пакетів (Package Diagram), діаграма взаємодії (Interaction Overview Diagram), діаграма діяльності (Activity Diagram) або діаграма станів (State Diagram). Ці діаграми повинні відображати основні аспекти структури та поведінки мобільного застосунку програмної системи.












3	ОПИС ВИКОНАНОЇ РОБОТИ


3.1  Архітектура мобільного застосунку програмної системи

Мобільний застосунок програмної системи розроблений за допомогою мови програмування Kotlin з використанням типової архітектури Android-застосунків, яка базується на принципах модульності та структурованого розділення відповідальностей. Такий підхід дозволяє забезпечити зручність у розробці, супроводі та масштабуванні системи.
Основна структура застосунку міститься в директорії app/src/main, де розташовано дві головні компоненти: папка res для зберігання ресурсів (інтерфейс, стилі, меню тощо) та каталог java/com/example/kotlintestapp, що містить вихідні .kt файли з бізнес-логікою та функціональними класами. Папка layout включає XML-файли, які відповідають за зовнішній вигляд окремих екранів і компонентів інтерфейсу користувача. Водночас, папка menu визначає структуру елементів меню, які використовуються в застосунку.
У структурі вихідного коду дотримано логічного поділу на активності (Activity), адаптери, фрагменти (у разі потреби) та допоміжні сервіси. Це дозволяє легко масштабувати проєкт та ізолювати відповідальність між модулями. Крім того, застосовується патерн MVC (Model-View-Controller), в якому:
	Model відповідає за доступ до даних та роботу з API;
	View реалізується через XML-інтерфейси в layout;
	Controller реалізований у вигляді класів Activity або Fragment, які реагують на дії користувача, викликають API, обробляють дані та оновлюють інтерфейс.
У майбутньому ця структура може легко трансформуватись у MVVM (Model-View-ViewModel) для ще кращого відокремлення логіки інтерфейсу від бізнес-логіки.
Однією з важливих переваг архітектури є підтримка зворотного зв’язку з серверною частиною програмної системи через API. Застосунок використовує HTTP-клієнт (наприклад, OkHttp у зв’язці з Retrofit) для обміну даними з бекендом. Зв’язок із сервером організовано через клієнтські виклики, які реалізуються у спеціалізованих класах або сервісах, наприклад, з використанням ApiClient. Дані серіалізуються у формат JSON і передаються на сервер за допомогою RequestBody та відповідних MediaType, що гарантує сумісність і ефективність при обробці запитів на стороні API.
Типовий запит до сервера передбачає використання POST- або GET-запитів, обробку відповіді сервера, а також належну обробку помилок і вивід повідомлень користувачу через компоненти Android, такі як Toast, або відображення повідомлень у інтерфейсі. Інтерфейс зберігає високу динамічність завдяки використанню таких компонентів, як RecyclerView з адаптерами, що дозволяє ефективно представляти списки даних, отриманих із сервера.
До основних переваг обраної архітектури можна віднести:
	Логічне розділення відповідальностей, що сприяє чистоті коду та легкому супроводу;
	Зручність масштабування, з можливістю швидко додавати нові екрани або функціональність;
	Проста інтеграція з бекендом, яка дозволяє реалізувати авторизацію, отримання динамічного вмісту, надсилання форм тощо;
	Гнучкість у розширенні архітектури для впровадження нових патернів (MVVM, Repository, Dependency Injection);
	Використання перевірених бібліотек для HTTP-запитів (OkHttp, Retrofit), що гарантує надійність комунікації з сервером.
Таким чином, мобільний застосунок має добре структуровану, підтримувану та ефективну архітектуру, яка відповідає сучасним вимогам до Android-розробки. Архітектура забезпечує стабільність роботи, зручність розробки нового функціоналу та високу адаптивність до змін у логіці всієї програмної системи.
Компонентна діаграма ілюструє архітектуру програмної системи, що складається з кількох ключових частин: фронтенд-сервера, сервера додатка, системи управління базами даних (СУБД) та мобільного застосунку рис.3.1. Особлива увага приділяється мобільному застосунку, який розроблений за допомогою мови Kotlin з дотриманням архітектурного патерну MVC (Model-View-Controller), що забезпечує структуроване розділення відповідальностей і сприяє зручному масштабуванню.
Мобільний застосунок поділено на кілька внутрішніх модулів. Компонент View, що реалізується у вигляді XML Layouts, відповідає за побудову графічного інтерфейсу користувача. Компонент Controller, представлений класами Activities або Fragments, реагує на дії користувача, обробляє події, ініціює виклики API та оновлює інтерфейс на основі отриманих даних. Компонент Model реалізовано у вигляді API-клієнта, що відповідає за взаємодію з бекендом і обробку відповідей сервера. Ключовим елементом моделі є ApiClient, побудований із використанням бібліотек OkHttp і Retrofit, що дозволяє здійснювати HTTP-запити до сервера додатка, передаючи та приймаючи дані у форматі JSON. Завдяки цим компонентам, мобільний застосунок забезпечує стабільну та ефективну двосторонню взаємодію з бекендом, виконуючи запити типу GET та POST до серверного API.
Для відображення динамічного контенту, отриманого з сервера, мобільний застосунок використовує Adapters, зокрема в парі з RecyclerView, що дозволяє зручно і гнучко візуалізувати списки. Крім того, застосунок містить Menu/Resources, які відповідають за стилізацію, побудову меню та зберігання додаткових ресурсів, необхідних для повноцінного функціонування інтерфейсу. Уся структура мобільного застосунку логічно організована, що дозволяє легко впроваджувати нові екрани, оновлювати функціонал та масштабувати рішення.
Зв’язок мобільного застосунку з бекендом здійснюється через HTTP-інтерфейс, що об'єднує його з сервером додатка. Сервер додатка побудований з використанням Flask і включає бізнес-логіку, SQLAlchemy ORM для роботи з базою даних, модуль авторизації JWT та логіку резервного копіювання. Через API мобільний застосунок може автентифікуватися, запитувати або змінювати дані, надсилати форми та отримувати відповіді, які далі обробляються відповідно до внутрішньої логіки контролерів.
Таким чином, мобільний застосунок є повноцінною та інтегрованою частиною всієї архітектури програмної системи, виконуючи роль зручного і функціонального клієнта, який забезпечує мобільний доступ до можливостей серверної частини через стандартизовані інтерфейси. Його структура створена з урахуванням кращих практик Android-розробки, що робить його гнучким, підтримуваним і ефективним у реальному використанні.


Рисунок 3.1 – UML Діаграма компонентів


3.2	   Бізнес-логіка мобільного затосунку програмної системи


UML-діаграма прецедентів моделює функціональні можливості мобільного застосунку веб-клієнта системи банку крові, орієнтовані на дві основні категорії користувачів: донора та транспортувальника рис.3.2. Вона демонструє типову взаємодію користувачів із системою, ілюструючи їхні можливості через логічно згруповані випадки використання.
Обидві ролі — і донор, і транспортувальник — мають доступ до базової функціональності мобільного застосунку, зокрема здійснюють авторизацію в системі, що є обов'язковою передумовою для подальшої роботи. Після входу до системи донор отримує можливість переглядати особисту інформацію у своєму профілі та редагувати її, що дозволяє підтримувати актуальність персональних даних. Крім того, донор має доступ до рекомендацій щодо підготовки до здачі крові, що сприяє підвищенню ефективності донорства. Також він може переглядати список власних донорських здач, що допомагає вести облік попередніх донацій. Важливою складовою є перегляд повідомлення про загальну кількість зданої крові, який реалізовано з використанням відношення «include», тобто він є частиною функціоналу перегляду донацій і виводить сумарні показники, що мотивують користувача та формують статистику.
Транспортувальник, у свою чергу, володіє іншим функціональним набором, який відповідає його операційній ролі в системі. Після авторизації він має доступ до переліку усіх замовлень, що дозволяє йому отримувати актуальну інформацію щодо перевезень. Під час виконання своїх обов’язків транспортувальник може встановлювати позначки про початок і кінець перевезення, що фіксує етапи транспортування і дозволяє системі відстежувати його тривалість. Одним із ключових аспектів є перегляд даних із датчиків у холодильниках, який забезпечує контроль за температурними умовами зберігання крові під час перевезення. Цей функціонал тісно пов’язаний із можливістю реагування на порушення умов зберігання, яка позначена відношенням «extend», що вказує на її залежність від попереднього процесу: вона активується тільки у разі фіксації порушення за допомогою датчиків. Таким чином, застосунок не лише інформує користувача, а й дозволяє оперативно реагувати на ризики, пов’язані з якістю транспортування.

Рисунок 3.2 – UML -діаграма прецедентів

UML діаграму діяльності ілюструє автоматизований процес формування, обробки та виконання заявки на компоненти крові між лікарнею, банком крові та службою транспортування рис.3.3. Вона відображає чітку послідовність дій, в якій задіяні різні учасники процесу, та акцентує увагу на високому рівні автоматизації, що значно підвищує швидкість, точність і контроль на всіх етапах доставки компонентів крові.
Процес починається з ініціації заявки медичним працівником лікарні, що дозволяє швидко реагувати на потребу в компонентах крові. Працівник вказує перелік та кількість необхідних компонентів, після чого ці дані одразу обробляються системою без потреби у ручному втручанні. Такий підхід мінімізує ризик помилок під час заповнення документації, пришвидшує реагування на клінічні потреби та забезпечує зручність у роботі персоналу.
Система автоматично аналізує запит, здійснюючи пошук відповідного банку крові, який може повністю або частково покрити потребу. Якщо банк із повною кількістю не знайдено, система не зупиняє процес, а автоматично коригує обсяг замовлення, враховуючи наявні запаси, і пропонує банк, який максимально може задовольнити запит. Це дозволяє уникнути відмов у постачанні, оперативно пристосовуватись до обставин та гарантувати щонайменше часткове виконання критичних замовлень.
Після визначення постачальника, замовлення надсилається банку крові, де воно обробляється відповідальними особами. Важливо, що процес не зупиняється на цьому етапі: одразу після підтвердження системою автоматично призначається транспортувальник, що скорочує час на логістичну координацію та виключає затримки через людський фактор. Передача замовлення транспортувальнику також фіксується в системі.
Після доставки до лікарні відповідальний медичний працівник підтверджує отримання, після чого система змінює статус замовлення, фіксуючи завершення циклу. Усі дані про доставку автоматично вносяться до журналу транспортувань і відображаються у звітності, що формує повну картину руху компонентів крові та забезпечує контроль на рівні адміністрації й аудиторських служб.



Рисунок 3.3  – UML -діаграма діяльності
Діаграма станів ілюструє логіку роботи інформаційної системи, розробленої для автоматизації процесу обліку та обробки поставок крові в банку крові 3.4. Вона відображає покрокову зміну станів об’єкта “Поставка крові” — від моменту її фізичного надходження до інтеграції отриманих даних в аналітичні інструменти. Важливо підкреслити, що в сучасній трансфузійній практиці кров не зберігається в цільному вигляді: одразу після надходження вона проходить процес фракціонування на окремі компоненти, такі як еритроцити, тромбоцити, плазма тощо. Саме ця особливість стала основою для побудови логіки системи, що дозволяє не лише фіксувати поставку як єдине ціле, а й у подальшому здійснювати облік, зберігання та аналітичний супровід кожного компонента окремо.
Після надходження поставки до банку крові система фіксує її як подію, яка запускає цикл подальшої обробки. Працівник банку реєструє поставку, вносячи унікальний номер та дату надходження. На наступному етапі система дозволяє внести інформацію про кожен окремий пакет крові: об’єм, умови транспортування, упаковку, термін придатності. Усе це зберігається централізовано в базі даних, забезпечуючи безперервність та точність обліку. Після реєстрації кожного пакета система переходить до етапу обробки — кров віртуально розділяється на її компоненти, кожен з яких фіксується як окрема сутність із власними параметрами: типом компонента, терміном придатності, допустимими умовами зберігання та призначенням. Це дозволяє надалі гнучко керувати запасами, уникати втрат через прострочення та оперативно реагувати на запити лікарень.
Після завершення обробки дані про поставку автоматично інтегруються у внутрішню аналітику системи. Вона формує звіти про поточні запаси, відображає розподіл компонентів, дозволяє аналізувати динаміку надходжень і використання в розрізі часу, типів крові або компонентів. 
Таким чином, інформаційна система не лише замінює ручну роботу з документацією, а й створює гнучке та надійне середовище для управління ресурсами банку крові відповідно до сучасних вимог. Вона забезпечує повну відповідність реальним медичним процесам, мінімізує ризики, підвищує безпеку пацієнтів та дозволяє ухвалювати обґрунтовані управлінські рішення на основі достовірних даних.
 
Рисунок 3.4 – UML -діаграма станів
3.3	    Опис інтерфейсу мобільного застосунку програмної системи


Після завантаження мобільного додатку користувач бачить на екрані іконку застосунку, яка зображає краплю крові на руці рис.3.5.

Рисунок  3.5 – Демонстрація іконки додатку

	Після натискання на іконку відкривається сторінка авторизації, де користувачеві пропонується ввести адресу електронної пошти та пароль. У разі некоректного введення даних система виводить відповідне повідомленнярис.3.6.

Рисунок 3.6  – Сторінка логіну у системі

	Після успішної авторизації система перенаправляє користувача на головну сторінку, яка відповідає його ролі рис.3.7. Наприклад, транспортувальник бачить на головному екрані своє ПІБ та електронну адресу.










Рисунок 3.7  – Сторінка з особистими даними користувача з ролью транспортувальника
	У транспортувальника в нижній частині екрана розміщено дві вкладки: одна для перегляду особистої інформації, інша — для перегляду замовлень рис.3.8. У списку замовлень відображаються: номер замовлення, маршрут доставки, дата та час початку й завершення перевезення, а також поточний статус. Коли транспортувальник отримує замовлення, воно з’являється в загальному переліку з зазначеною адресою та відповідним статусом. Для початку доставки потрібно натиснути на кнопку Start — система фіксує час початку та змінює статус замовлення. Після завершення доставки транспортувальник натискає Complete, система зберігає час завершення і змінює статус доставки.
Рисунок 3.8 – Сторінка з переліком усіх замовлень транспортувальника

Під час транспортування крові до лікарні транспортувальник має можливість моніторити показники датчиків у холодильниках з компонентами крові. На сторінці моніторингу відображається назва і номер кожного холодильника, актуальна температура та статус рис.3.9. Кожен компонент крові має власну критичну межу температури, тому для кожного холодильника встановлено індивідуальні параметри контролю.







Рисунок 3.9 – Сторінка моніторингу датчиків з холодильників під час доставки

Після входу до системи донор на головній сторінці бачить свої персональні дані: ПІБ, стать, дату народження, вік, резус-фактор, електронну пошту та контактний номер телефону рис.3.10. В нижній частині екрана розміщено три вкладки для навігації.




Рисунок 3.10 – Головна сторінка донора

	Донор може змінити свій контактний номер, натиснувши на іконку олівця у правому верхньому куті рис.3.11.


Рисунок 3.11 – Вікно редагування номеру телефону

	При переході на вкладку Info донору доступна інформація з рекомендаціями щодо підготовки до донації рис.3.12. Ці поради допомагають уникати поширених помилок, краще підготуватись до здачі крові, а також виконують мотиваційну функцію.








Рисунок 3.12 – Сторінка переліку рекомендацій до підготовки до донації

	Також донор може переглянути історію власних донацій рис.3.13. У списку зазначаються дата здачі крові, об’єм (у мл) та центр, у якому відбувалася донація. Крім того, вгорі сторінки виводиться загальна кількість зданої крові, що слугує додатковою мотивацією та дозволяє донору краще усвідомити важливість своєї участі.

Рисунок 3.13 – Сторінка перегляду історії донацій донора


3.4	   Захист даних у мобільному застосунку програмної системи


Мобільна частина програмної системи реалізована з урахуванням сучасних вимог до інформаційної безпеки, особливо в контексті обробки персональних та медичних даних. Захист користувацьких даних починається вже на етапі аутентифікації, яка відбувається через передачу облікових даних (електронної пошти та пароля) по захищеному HTTP-з'єднанню до серверної частини системи.
Після успішного проходження авторизації, користувач отримує токен доступу у форматі JWT (JSON Web Token). Цей токен використовується для підтвердження особи користувача під час наступних запитів до серверу. JWT є одним з найбільш поширених механізмів авторизації в сучасних мобільних додатках завдяки своїй компактності, безпечності та можливості локального збереження даних про сесію користувача. Токени містять у собі зашифровану інформацію, підписану на стороні сервера, що унеможливлює підміну даних чи несанкціонований доступ до ресурсів.
Кожен запит, який виконується мобільним додатком до бекенду, супроводжується передачею токена у заголовках запиту. Це забезпечує захист від неавторизованого доступу навіть у випадку повторного відкриття застосунку без повторної аутентифікації. З боку клієнта реалізовано обробку помилок авторизації, що дозволяє оперативно реагувати на спроби входу з некоректними даними або втрату дійсності токена.
Додаткову безпеку мобільної частини забезпечує використання мови програмування Kotlin, яка завдяки своїй нуль-безпечній природі (null-safety) і суворій типізації значно зменшує ризик помилок, пов’язаних із неправильною обробкою даних або вразливостями в логіці програми. Kotlin також дозволяє реалізовувати сучасні підходи до побудови архітектури клієнтської частини, забезпечуючи чітке розмежування між відповідальністю за дані, логікою та інтерфейсом користувача.
Варто також зазначити, що передача даних, таких як електронна пошта та ідентифікатор користувача, не відбувається без попереднього кодування або захисту. Всі критичні значення попередньо обробляються та передаються без можливості прямої підстановки, що мінімізує ризики, пов’язані з атакою типу «людина посередині» або підміною даних на клієнтському рівні.
Таким чином, мобільна частина програмної системи забезпечує багаторівневий захист даних завдяки використанню JWT-токенів, HTTPS-протоколу, внутрішніх механізмів перевірки даних, переваг мови Kotlin, а також завдяки структурованій обробці запитів і відповідей між клієнтом і сервером.


3.5	    Висновки


У ході виконання лабораторної роботи було проведено детальний аналіз архітектури мобільного застосунку програмної системи для управління банками крові та координації донорських процесів. Визначено основні компоненти, з яких складається застосунок, а також програмні технології, що були використані для його реалізації. Окрему увагу приділено опису бізнес-логіки, яка охоплює функціональність реєстрації та авторизації донорів, перегляд історії донорських сесій, отримання персоналізованих рекомендацій та сповіщень, а також взаємодії з іншими модулями системи, зокрема з центральним сервером, модулями обробки заявок та транспортування.
Забезпечено захист даних через використання сучасних методів автентифікації та авторизації, а також дотримання принципів безпечного зберігання та передачі інформації. Реалізовано підтримку інтерналізації та локалізації, що дозволяє адаптувати інтерфейс мобільного застосунку до різних мовних та культурних середовищ користувачів.
До звіту включено UML-діаграму прецедентів і діаграму компонентів, які наочно ілюструють функціональні можливості мобільного застосунку та його архітектуру. Додатково побудовано дві діаграми на вибір: діаграма діяльності, що демонструє процес використання основного функціоналу донором, та діаграма станів, яка відображає життєвий цикл основних об'єктів застосунку.




ДОДАТОК А
Хронологічний опис відео

Відеозапис доповіді на YouTube: https://youtu.be/2l_1K4xJRoo
Хронологічний опис відео
00:00 Вступ 
00:10 Розділ 2 Завдання до лабораторної роботи 
00:43 Розділ 3.1 Архітектура мобільного застосунку програмної системи 
05:40 Розділ 3.2 Бізнес-логіка мобільного затосунку програмної системи 
12:00 Розділ 3.3 Опис інтерфейсу мобільного застосунку програмної системи 
14:22 Розділ 3.4 Захист даних у мобільному застосунку програмної системи 
15:35 Демонстрація роботи мобільного застосунку


























ДОДОТОК Б



  1  package com.example.kotlintestapp
  2  
  3  import ApiClient
  4  import android.os.Bundle
  5  import android.util.Log
  6  import android.view.View
  7  import android.widget.LinearLayout
  8  import android.widget.TextView
  9  import android.widget.Toast
 10  import androidx.appcompat.app.AppCompatActivity
 11  import org.json.JSONArray
 12  
 13  class SensorsDetails : AppCompatActivity() {
 14      private val apiClient = ApiClient()
 15      private lateinit var baseUrl: String
 16  
 17      private lateinit var sensorsContainer: LinearLayout
 18  
 19      override fun onCreate(savedInstanceState: Bundle?) {
 20          super.onCreate(savedInstanceState)
 21          setContentView(R.layout.sensors_details)
 22  
 23          sensorsContainer = findViewById(R.id.sensorsContainer)
 24  
 25          baseUrl = getString(R.string.base_url)
 26  
 27          val transportId = intent.getStringExtra("transport_id")
 28          if (transportId != null) {
 29              Log.d("SensorsDetails", "before fetching")
 30              for (sensorId in 1..3) {
 31                  fetchSensorData(transportId, sensorId)
 32              }
 33          } else {
 34              Toast.makeText(this, "No Transport ID found", Toast.LENGTH_SHORT).show()
 35          }
 36      }
 37  
 38      private fun fetchSensorData(transportId: String, sensorId: Int) {
 39          val url = "$baseUrl/transport-sensor/$transportId/$sensorId"
 40          Log.d("SensorsDetails", "Fetching $url")
 41  
 42          apiClient.fetchData(this, url) { response, statusCode ->
 43              runOnUiThread {
 44                  if (statusCode == 200) {
 45                      try {
 46                          val jsonArray = JSONArray(response)
 47                          if (jsonArray.length() > 0) {
 48                              val firstItem = jsonArray.getJSONObject(0)
 49  
 50                              val bloodFridgeId = firstItem.getInt("blood_fridge_id")
 51                              val bloodFridgeName = firstItem.getString("blood_fridge_name")
 52                              val status = firstItem.getString("status")
 53                              val temperature = firstItem.getDouble("temperature")
 54                              val timestamp = firstItem.getString("time_stamp")
 55  
 56                              addSensorBlock(sensorId, bloodFridgeId, bloodFridgeName, status, temperature, timestamp)
 57  
 58                              Log.d("SensorsDetails", "Sensor $sensorId data loaded")
 59  
 60                          } else {
 61                              Toast.makeText(this, "No data found for sensor $sensorId", Toast.LENGTH_SHORT).show()
 62                          }
 63                      } catch (e: Exception) {
 64                          Toast.makeText(this, "Error parsing sensor $sensorId data", Toast.LENGTH_SHORT).show()
 65                          Log.e("SensorsDetails", "JSON Parsing error for sensor $sensorId", e)
 66                      }
 67                  } else {
 68                      Toast.makeText(this, "Failed to fetch sensor $sensorId: $statusCode", Toast.LENGTH_SHORT).show()
 69                      Log.e("SensorsDetails", "Failed sensor $sensorId with status: $statusCode")
 70                  }
 71              }
 72          }
 73      }
 74  
 75      private fun addSensorBlock(sensorId: Int, bloodFridgeId: Int, bloodFridgeName: String, status: String, temperature: Double, timestamp: String) {
 76          val sensorTextView = TextView(this).apply {
 77              text = """
 78                  
 79                  Fridge ID: $bloodFridgeId
 80                  
 81                  Fridge Name: $bloodFridgeName
 82                  
 83                  Status: $status
 84                  
 85                  Temperature: $temperature°C
 86                  
 87                  Timestamp: $timestamp
 88                  
 89              """.trimIndent()
 90              textSize = 18f
 91              setTextColor(resources.getColor(android.R.color.black))
 92          }
 93  
 94          sensorsContainer.addView(sensorTextView)
 95  
 96          val line = View(this).apply {
 97              layoutParams = LinearLayout.LayoutParams(
 98                  LinearLayout.LayoutParams.MATCH_PARENT,
 99                  2
100              ).apply {
101                  topMargin = 16
102                  bottomMargin = 16
103              }
104              setBackgroundColor(resources.getColor(android.R.color.darker_gray))
105          }
106  
107          sensorsContainer.addView(line)
108      }
109  }
