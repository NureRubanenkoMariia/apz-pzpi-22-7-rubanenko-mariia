Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії



Звіт
з практичної роботи №1
з дисципліни «Архітектура програмного забезпечення»
з теми: «Патерни проектування»





Виконала 								Перевірив
ст. гр. ПЗПІ-22-7 							ст. викладач кафедри ПІ
Рубаненко М. С.                                                               Сокорчук І. П.








Харків 2025

1 ПАТЕРНИ ПРОЄКТУВАННЯ

1.1 Історія змін

Таблиця 1.1 відображає зміни, внесені до документа.
№	Дата	Версія звіту	Опис змін та виправлень
1	21.04.2025	0.1	Розділ «Історія змін» було додано до документа
2	21.04.2025	0.1	Розділ «Завдання до практичної роботи» було додано до документа
3	21.04.2025	0.1	Розділ «Опис виконаної роботи» було додано до документа
4	21.04.2025	0.1	Розділ «Висновки» було додано до документа
5	21.04.2025	0.1	У документ включено «Додаток А» з посиланням на відеоролик
6	21.04.2025	0.1	У документ включено «Додаток Б» з слайдами презентації
7	21.04.2025	0.1	У документ включено «Додаток В» з програмним кодом



1.2 Завдання до практичної роботи

Метою цієї практичної роботи є детальне вивчення шаблону проєктування Template Method, який належить до поведінкових патернів та широко використовується в об’єктно-орієнтованому програмуванні. Необхідно з’ясувати, як цей патерн дає змогу визначити каркас певного алгоритму в базовому класі, залишаючи можливість реалізувати окремі етапи цього алгоритму в підкласах. Такий підхід сприяє повторному використанню коду та забезпечує чітке розділення відповідальностей між загальною логікою і специфічними реалізаціями. 
У межах завдання потрібно реалізувати власний приклад Template Method, що демонструє застосування патерна в умовах практичної задачі. Крім програмної реалізації, слід надати аналіз переваг та недоліків шаблонного методу, звертаючи увагу на його гнучкість у повторному використанні алгоритмів та обмеження, пов’язані з жорсткою структурою спадкування. Рекомендується також розглянути можливі альтернативні підходи, зокрема інші патерни.

1.3 Опис виконаної роботи

У межах цієї практичної роботи було досліджено патерн проєктування Template Method, який належить до поведінкових патернів і активно використовується в об’єктно-орієнтованому програмуванні. Основна ідея цього патерну полягає у визначенні загальної структури алгоритму в базовому класі, залишаючи реалізацію окремих його етапів у підкласах. Таким чином, Template Method дозволяє стандартизувати процеси, зберігаючи при цьому гнучкість у деталях їх реалізації.
Цей підхід дозволяє уніфікувати логіку високого рівня, гарантуючи дотримання певної послідовності дій, при цьому делегуючи реалізацію окремих кроків до нащадків. Базовий клас містить метод-шаблон (template method), який викликає абстрактні або частково реалізовані методи, що перевизначаються в підкласах.
У межах роботи було реалізовано приклад на Python з використанням мікрофреймворку Flask, який демонструє можливості патерну Template Method. Ця реалізація ілюструє ключову перевагу Template Method — можливість розширення поведінки без порушення загальної логіки. Замість дублювання схожих алгоритмів у різних класах, спільна частина винесена у базовий клас, що значно покращує підтримку та масштабованість коду.
Серед інших переваг шаблонного методу можна виділити:
	контроль над структурою алгоритму, що забезпечує послідовність дій;
	можливість повторного використання коду за рахунок спільної логіки в базовому класі;
	простоту розширення за допомогою нових підкласів.
Проте Template Method має і певні недоліки. Основний з них полягає у жорсткій прив’язці до спадкування, що знижує гнучкість у порівнянні з композицією. У мовах без підтримки множинного успадкування можуть виникати обмеження при повторному використанні коду в різних контекстах. Крім того, надмірне застосування шаблонних методів може призводити до надмірної кількості підкласів, що ускладнює підтримку системи.
Як альтернативу Template Method часто використовують патерн Strategy, який дозволяє змінювати окремі алгоритми на льоту, використовуючи композицію замість спадкування. Strategy забезпечує більшу гнучкість, однак не гарантує послідовність виконання всіх частин алгоритму, що є перевагою Template Method у задачах, де важливий чіткий порядок дій.
Загалом, реалізований приклад і проведений аналіз показали, що Template Method є потужним інструментом у розробці програмного забезпечення, коли потрібно поєднати фіксовану структуру обробки із варіативністю реалізації окремих етапів. Патерн дозволяє спростити підтримку коду, зменшити дублікацію та підвищити якість архітектури програмної системи.



1.4 Висновок

У результаті виконання практичної роботи було детально розглянуто патерн проєктування Template Method, що належить до поведінкових шаблонів та широко використовується для організації структури алгоритмів у базових класах з можливістю зміни окремих кроків у підкласах. Реалізований приклад чітко продемонстрував, як можна забезпечити однорідність логіки виконання та одночасно залишити гнучкість реалізації в окремих компонентах системи.










ДОДАТОК А
Хронологічний опис відео

Відеозапис доповіді на YouTube: https://youtu.be/IeUNYDOJSJs

Хронологічний опис відео: 
00:00 Вступ 
00:12 Зміст презентації 
00:14 Що таке патерни проектування 
01:45 Чому варто використовувати патерни проєктування? 
02:10 Патерн Template Method 
03:01 Структура патерну 
04:49 Використання Template Method 
05:50 Приклад використання Template Method у Flask 
07:19 Використання в реальних проєктах 
08:48 Переваги патерну Template Method 
09:53 Недоліки патерну Template Method 
12:15 Порівняння з іншими патернами 
13:10 Висновки 
13:40 Список використаних джерел

Посилання на файл з кодом в GitHub репозиторії:








ДОДАТОК Б
Слайди презентації

 
Рисунок Б.1 –Титульний слайд презентації

 
Рисунок Б.2 – Слайд зі змістом презентації
 
Рисунок Б.3 – Слайд з поясненням концепції патернів проектування

 
Рисунок Б.4 – Слайд з поясненням використання патернів проектування
 
Рисунок Б.5 –Слайд з описом патерну Template Method

 Рисунок Б.6 – Слайд з поясненням структури патерну Template Method
 
Рисунок Б.7 – Слайд з поясненням застосування патерну Template Method

 
Рисунок Б.8 – Слайд прикладом використання Template Method
 
Рисунок Б.9 – Слайд з описом використання патерну Template Method у розробці веб-додатків

 
Рисунок Б.10 – Слайд з описом переваг патерну Template Method
 
Рисунок Б.11 – Слайд з описом недоліків Template Method

 
Рисунок Б.12 –Слайд з порівнянням патернів Template Method та Strategy
 Рисунок Б.13 – Слайд з висновками

 Рисунок Б.14 – Слайд з списком використаних джерел




ДОДАТОК В
Приклад реалізації патерну на Python

1 from flask import Flask, request, jsonify
2 
3 app = Flask(__name__)
4 
5 # Base class that defines a template method for API handlers
6 class BaseAPIHandler:
7     def handle_request(self):
8         """Template Method: defines the general algorithm for processing an API request"""
9         if request.method == "GET":
10             data = self.get_data()
11         elif request.method == "POST":
12             data = self.create_data()
13         else:
14             return jsonify({"error": "Method not supported"}), 405
15 
16         return self.format_response(data)
17 
18     def format_response(self, data):
19         """Formats the response into a unified JSON format"""
20         return jsonify({"status": "success", "data": data})
21 
22     def get_data(self):
23         """Abstract method for retrieving data (implemented in subclasses)"""
24         raise NotImplementedError("The get_data() method must be implemented in a subclass")
25 
26     def create_data(self):
27         """Abstract method for creating data (implemented in subclasses)"""
28         raise NotImplementedError("The create_data() method must be implemented in a subclass")
29 
30 # API implementation for handling orders
31 class OrderAPI(BaseAPIHandler):
32     def get_data(self):
33         """Retrieve a list of orders"""
34         return [{"order_id": 1, "amount": 100}, {"order_id": 2, "amount": 200}]
35 
36     def create_data(self):
37         """Create a new order"""
38         new_order = request.json
39         return {"message": "Order created", "order": new_order}
40 
41 # API implementation for handling payments
42 class PaymentAPI(BaseAPIHandler):
43     def get_data(self):
44         """Retrieve a list of payments"""
45         return [{"payment_id": 101, "status": "Completed"}, {"payment_id": 102, "status": "Pending"}]
46 
47     def create_data(self):
48         """Process a new payment"""
49         new_payment = request.json
50         return {"message": "Payment processed", "payment": new_payment}
51 
52 # Register routes in Flask
53 @app.route("/orders", methods=["GET", "POST"])
54 def orders():
55     return OrderAPI().handle_request()
56 
57 @app.route("/payments", methods=["GET", "POST"])
58 def payments():
59     return PaymentAPI().handle_request()
60 
61 if __name__ == "__main__":
62     app.run(debug=True)



