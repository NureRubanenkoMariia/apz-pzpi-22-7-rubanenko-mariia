Міністерство освіти і науки України
Харківський національний  університет радіоелектроніки


Кафедра програмної інженерії 



Лабораторна робота №3
 з дисципліни: «Архітектура програмного забезпечення» 
на тему «Розробка програмної архітектури, створення та відлагодження програмного коду веб клієнта програмної системи»





Виконала
ст. гр. ПЗПІ-22-7
Рубаненко Марія Сергіївна
03 травня 2025 р.
Перевірив
ст. викл. Сокорчук І. П.





Харків 2025

1 ІСТОРІЯ ЗМІН

Таблиця 1.1 відображає зміни, внесені до документа.
Таблиця 1.1 - Історія змін
№	Дата	Версія звіту	Опис змін та виправлень
1	03.05.2025	0.1	Розділ «Історія змін» було додано до документа
2	03.05.2025	0.1	Розділ «Завдання до лабораторної роботи» було додано до документа
3	03.05.2025	0.1	Розділ «Опис виконаної роботи» було додано до документа
4	03.05.2025	0.1	Розділ «Висновки» було додано до документа
5	03.05.2025	0.1	У документ включено «Додаток А» з посиланням на відеоролик
6	03.05.2025	0.1	У документ включено «Додаток Б» 














2 ЗАВДАННЯ


У рамках лабораторної роботи необхідно проаналізувати та описати архітектуру веб частини розроблюваної програмної системи. Потрібно визначити використовувані програмні технології, компоненти, з яких складається веб частина, а також функціональні можливості, що реалізовані в цій частині системи. Особливу увагу слід приділити опису реалізованої бізнес-логіки, засобів захисту даних, взаємодії веб частини з іншими модулями програмної системи, а також підтримці інтерналізації та локалізації. Необхідно описати варіанти локалізації, які реалізовані у веб частині, та засоби адміністрування і налаштування, доступні через неї.
До звіту потрібно включити UML-діаграму прецедентів (Use Case Diagram) та UML-діаграму компонент (Component Diagram). Крім того, слід побудувати не менше двох UML-діаграм на вибір із наступного переліку: діаграма пакетів (Package Diagram), діаграма взаємодії (Interaction Overview Diagram), діаграма діяльності (Activity Diagram) або діаграма станів (State Diagram). Ці діаграми повинні відображати основні аспекти структури та поведінки веб частини програмної системи.











3	ОПИС ВИКОНАНОЇ РОБОТИ


3.1  Архітектура веб-частини програмної системи

Веб-частина програмної системи банку крові побудована за принципом клієнт-серверної архітектури, де роль веб-клієнта виконує фронтенд, реалізований за допомогою фреймворку Django, а основна бізнес-логіка і робота з базами даних делегована окремому бекенду, створеному на Flask. Такий підхід відповідає сучасній моделі API-first, у якій веб-клієнт взаємодіє з сервером виключно через HTTP-запити до REST API. Це забезпечує чітке розділення відповідальностей, високу гнучкість, можливість масштабування, а також відкриває перспективи повторного використання API для інших клієнтів, зокрема мобільних застосунків або IoT-пристроїв.
Фронтенд на Django реалізовано відповідно до класичного шаблону Model-View-Template (MVT), який за своєю суттю є аналогом широко відомої архітектури MVC. У цій моделі логіка представлення організована у вигляді представлень (views), які приймають запити користувача, опрацьовують їх та передають результати у шаблони (templates), що відповідають за відображення даних. У структурі проєкту передбачено логічне розділення на окремі додатки (apps), кожен з яких відповідає за певну частину функціональності. Така організація забезпечує зручність розробки, простоту масштабування і дає можливість повторно використовувати частини коду.
Побудова інтерфейсу користувача здійснюється із використанням Django-шаблонів, що дозволяє створювати динамічні HTML-сторінки з підтримкою умов, циклів, наслідування шаблонів та вставок. Дані у формати для представлення подаються представленнями, які можуть виконувати запити до бекенду або самостійно обробляти певну частину логіки, наприклад, локалізацію або побудову форм. Django також має вбудовану підтримку форм — серверна логіка дозволяє швидко створювати форми з валідацією та зручним відображенням на стороні клієнта. Крім цього, у веб-частині реалізована повноцінна підтримка інтернаціоналізації — багатомовність інтерфейсу забезпечена використанням вбудованих механізмів Django i18n/l10n.
Хоча Django традиційно використовується як повноцінний фреймворк з ORM та власною логікою, у даному випадку він виконує роль фронтенда, який взаємодіє з окремим сервером на Flask. Уся логіка обробки даних, доступу до бази, перевірки дозволів тощо реалізована на Flask-бекенді, а Django надсилає до нього запити через HTTP. Це дозволяє фронтенду зосередитися виключно на інтерфейсі, делегуючи всю обчислювальну логіку серверу, що, у свою чергу, спрощує підтримку та розвиток обох частин системи.
У проєкті реалізовано кілька архітектурних і проєктних шаблонів. Основним є згаданий MVT, який дозволяє логічно розділити обов’язки між моделями, представленнями та шаблонами. У шаблонах застосовано патерн наслідування, що дає змогу визначити основний макет сторінки й перевикористовувати його на різних підсторінках, змінюючи лише окремі фрагменти. Крім цього, загальна структура URL-маршрутизації реалізована через єдиний центр керування запитами, що відповідає патерну Front Controller.
Django забезпечує швидку та безпечну розробку користувацьких інтерфейсів, підтримку багатомовності та зручну інтеграцію з API, а Flask-бекенд дозволяє централізовано обробляти всі дані, логіку авторизації та доступу до ресурсів. Такий розподіл ролей між компонентами системи створює чітку архітектуру, яка легко масштабуються та адаптується до нових функціональних вимог.

UML-діаграма компонентів відображає архітектуру веб-частини системи управління банком крові, зосереджену на взаємодії між клієнтським інтерфейсом (фронтендом), серверною логікою (бекендом) та базою даних рис.3.1. Архітектура базується на принципі клієнт-серверної моделі з чітким розподілом відповідальностей між компонентами, що забезпечує гнучкість, масштабованість та підтримку API-first підходу.
Фронтенд реалізований за допомогою Django і логічно поділений на декілька компонентів. Компонент User Interface (Django Templates) відповідає за формування HTML-сторінок за допомогою шаблонів, які підтримують спадкування, вставки, умови та цикли. Компонент Views обробляє вхідні HTTP-запити користувачів, виконує локальну логіку (наприклад, інтернаціоналізацію або валідацію форм) і направляє запити до бекенду. Forms забезпечують зручну обробку введення даних з автоматичною валідацією та відображенням на сторінках. Компонент URL Dispatcher реалізує маршрутізацію згідно з патерном Front Controller, спрямовуючи запити до відповідних обробників. Усі компоненти фронтенду взаємодіють із сервером через REST API Client, який надсилає HTTP-запити до бекенду.
Бекенд реалізований на Flask і виконує роль центрального обробника бізнес-логіки. Flask App приймає HTTP-запити від фронтенду та виконує обробку відповідно до визначених маршрутів. Компонент Business Logic Layer інкапсулює основну логіку обробки даних, включаючи перевірку прав доступу, обчислення, підготовку відповідей API тощо. Database Access Layer (ORM/SQLAlchemy) відповідає за взаємодію з базою даних, виконуючи запити, створення та зміну записів. Бекенд має безпосередній зв’язок із Relational Database, яка зберігає дані про донорів, запаси крові, заявки, користувачів, лікарні, тощо.
Між компонентами фронтенду та бекенду реалізований чіткий інтерфейс взаємодії через REST API. Це дозволяє не тільки використовувати Django як веб-клієнт, а й потенційно підключати інші клієнти (мобільні додатки, сторонні системи, IoT-пристрої) до тієї ж API-інфраструктури.
Така архітектура забезпечує зручну підтримку, можливість незалежної розробки фронтенду та бекенду, ефективну роботу в умовах навантаження, а також простоту розширення системи новими модулями й функціями.

Рисунок 3.1 – UML Діаграма прецедентів 


3.2	   Бізнес-логіка веб-частини програмної системи


UML діаграма прецедентів, зображена для веб-клієнта системи банку крові, демонструє основні функціональні можливості, які доступні різним користувачам платформи рис.3.2. У системі беруть участь чотири основні актори: адміністратор банку крові, працівник лікарні, працівник банку крові та працівник технічної підтримки. Кожен з них має власний набір ролей і функцій, що дозволяє ефективно керувати процесами, пов’язаними з обігом, зберіганням та постачанням крові.
Адміністратор банку крові виконує ключову роль у системі, координуючи роботу інших користувачів. Він відповідає за управління доступами до системи, включаючи реєстрацію працівників банку та представників лікарень. Крім того, адміністратор може призначати транспортувальників для виконання конкретних постачань, переглядати загальні звіти про ефективність роботи, кількість та якість постачань, а також аналітичні звіти щодо доставок крові до лікарень. Однією з критичних функцій є підтвердження заявок, які надходять від працівників лікарень, що дозволяє регулювати ланцюг постачання крові на рівні системи.
Працівник лікарні має доступ до створення заявок на постачання крові. У процесі створення заявки він може скористатися автоматичним пошуком найближчого або найбільш придатного банку крові, що оптимізує швидкість реагування на потребу. Працівник також може редагувати надіслані заявки, що дозволяє враховувати зміни в ситуації в лікарні.
Працівник банку крові, зі свого боку, здійснює процес обробки заявок, що надходять із лікарень. Також створює записи про доставку крові до банку та реєструє нових донорів у системі.
Технічна підтримка відповідає за технічну стабільність платформи. Її обов’язки включають адміністрування системи, оновлення системних компонентів та підтримку стабільності під час пікових навантажень, що критично важливо для забезпечення безперервної роботи сервісу.
Уся система побудована з урахуванням зв’язків між прецедентами, де деякі функції розширюють або включають інші. Наприклад, процес створення заявки на поставку крові може включати автоматичний пошук банку або редагування заявки, а перегляд звітності адміністратором розширюється окремими типами звітів — аналітичними або статистичними. Таким чином, діаграма наочно демонструє взаємодію між користувачами системи та її ключовими функціями, що забезпечують злагоджену й ефективну роботу веб-платформи банку крові.

Рисунок 3.2 – UML -діаграма прецедентів

UML діаграму діяльності ілюструє автоматизований процес формування, обробки та виконання заявки на компоненти крові між лікарнею, банком крові та службою транспортування рис.3.3. Вона відображає чітку послідовність дій, в якій задіяні різні учасники процесу, та акцентує увагу на високому рівні автоматизації, що значно підвищує швидкість, точність і контроль на всіх етапах доставки компонентів крові.
Процес починається з ініціації заявки медичним працівником лікарні, що дозволяє швидко реагувати на потребу в компонентах крові. Працівник вказує перелік та кількість необхідних компонентів, після чого ці дані одразу обробляються системою без потреби у ручному втручанні. Такий підхід мінімізує ризик помилок під час заповнення документації, пришвидшує реагування на клінічні потреби та забезпечує зручність у роботі персоналу.
Система автоматично аналізує запит, здійснюючи пошук відповідного банку крові, який може повністю або частково покрити потребу. Якщо банк із повною кількістю не знайдено, система не зупиняє процес, а автоматично коригує обсяг замовлення, враховуючи наявні запаси, і пропонує банк, який максимально може задовольнити запит. Це дозволяє уникнути відмов у постачанні, оперативно пристосовуватись до обставин та гарантувати щонайменше часткове виконання критичних замовлень.
Після визначення постачальника, замовлення надсилається банку крові, де воно обробляється відповідальними особами. Важливо, що процес не зупиняється на цьому етапі: одразу після підтвердження системою автоматично призначається транспортувальник, що скорочує час на логістичну координацію та виключає затримки через людський фактор. Передача замовлення транспортувальнику також фіксується в системі.
Після доставки до лікарні відповідальний медичний працівник підтверджує отримання, після чого система змінює статус замовлення, фіксуючи завершення циклу. Усі дані про доставку автоматично вносяться до журналу транспортувань і відображаються у звітності, що формує повну картину руху компонентів крові та забезпечує контроль на рівні адміністрації й аудиторських служб.



Рисунок 3.3  – UML -діаграма діяльності
Діаграма станів ілюструє логіку роботи інформаційної системи, розробленої для автоматизації процесу обліку та обробки поставок крові в банку крові 3.4. Вона відображає покрокову зміну станів об’єкта “Поставка крові” — від моменту її фізичного надходження до інтеграції отриманих даних в аналітичні інструменти. Важливо підкреслити, що в сучасній трансфузійній практиці кров не зберігається в цільному вигляді: одразу після надходження вона проходить процес фракціонування на окремі компоненти, такі як еритроцити, тромбоцити, плазма тощо. Саме ця особливість стала основою для побудови логіки системи, що дозволяє не лише фіксувати поставку як єдине ціле, а й у подальшому здійснювати облік, зберігання та аналітичний супровід кожного компонента окремо.
Після надходження поставки до банку крові система фіксує її як подію, яка запускає цикл подальшої обробки. Працівник банку реєструє поставку, вносячи унікальний номер та дату надходження. На наступному етапі система дозволяє внести інформацію про кожен окремий пакет крові: об’єм, умови транспортування, упаковку, термін придатності. Усе це зберігається централізовано в базі даних, забезпечуючи безперервність та точність обліку. Після реєстрації кожного пакета система переходить до етапу обробки — кров віртуально розділяється на її компоненти, кожен з яких фіксується як окрема сутність із власними параметрами: типом компонента, терміном придатності, допустимими умовами зберігання та призначенням. Це дозволяє надалі гнучко керувати запасами, уникати втрат через прострочення та оперативно реагувати на запити лікарень.
Після завершення обробки дані про поставку автоматично інтегруються у внутрішню аналітику системи. Вона формує звіти про поточні запаси, відображає розподіл компонентів, дозволяє аналізувати динаміку надходжень і використання в розрізі часу, типів крові або компонентів. 
Таким чином, інформаційна система не лише замінює ручну роботу з документацією, а й створює гнучке та надійне середовище для управління ресурсами банку крові відповідно до сучасних вимог. Вона забезпечує повну відповідність реальним медичним процесам, мінімізує ризики, підвищує безпеку пацієнтів та дозволяє ухвалювати обґрунтовані управлінські рішення на основі достовірних даних.

Рисунок 3.4 – UML -діаграма станів




3.3	    Опис інтерфейсу веб-клієнту програмної системи


При переході за посиланням користувача зустрічає вікно авторизації у системі, де необхідно ввести адресу електронної пошти та пароль. У разі введення некоректного пароля або помилки в написанні пошти, система виводить відповідне повідомлення з підказкою щодо виправлення рис.3.5.

Рисунок  3.5 – Сторінка входу у систему

Після успішної аутентифікації користувача система перенаправляє його на головну сторінку. У центрі сторінки розташований перелік новин сервісу — невеликі повідомлення про оновлення, впровадження нового функціоналу або важливі оголошення. Праворуч відображається календар із поточним часом, що є зручним інструментом для користувачів систем обліку та логістики. Зліва знаходиться навігаційна панель, що містить посилання на сторінки, доступні для перегляду та взаємодії згідно з роллю користувача рис.3.6.

Рисунок 3.6  – Головна сторінка системи

	Натиснувши на іконку користувача в лівому нижньому куті, користувач потрапляє на сторінку з особистими даними. Тут доступна можливість змінити пароль. Такий функціонал особливо важливий у випадках, коли адміністратор створює нового користувача — після створення облікового запису з типовим (дефолтним) паролем, користувач має змінити його при першому вході до системи рис.3.7.


Рисунок 3.7  – Сторінка з особистими даними користувача

Адміністратор банку має змогу переглядати список усіх користувачів, які належать до його установи. Для додавання нового користувача необхідно натиснути на червону кнопку у правому верхньому куті та заповнити форму, що з’явиться у модальному вікні 3.8.
Рисунок 3.8 – Сторінка для створення нового користувача

Крім того, адміністратор має доступ до аналітичних звітів банку крові. На сторінці з аналітикою представлена статистика, зокрема огляд поточних запасів компонентів крові, де червоним кольором позначені позиції, запаси яких закінчуються. Також виводиться перелік компонентів, у яких скоро спливає термін придатності 3.9-3.10.

Рисунок 3.9 – Сторінка огляду аналітичного звіту по наявності компонентів 

Рисунок 3.10 – Сторінка огяду аналітичного звіту з метриками по кількості поставок та відправлень
Працівник лікарні має можливість створювати заявки на постачання компонентів крові. Для цього необхідно натиснути червону кнопку у правому верхньому куті та заповнити відповідну форму, вказавши вид компоненту крові, резус-фактор та необхідну кількість. Крім того, користувач може переглядати усі створені заявки, їх зміст, а також відстежувати статус кожної із них безпосередньо на сайті рис.3.11-3.12.

Рисунок 3.111 – Сторінка огляду відправлень замовлень з банку
Рисунок 3.12 – Сторінка огляду деталей замовлення
Працівник банку крові має доступ до списку донорів, зареєстрованих у межах конкретного банку. Додати нового донора можна за допомогою червоної кнопки у правому верхньому куті. Такий функціонал дозволяє вносити до бази лише осіб, які пройшли необхідні медичні обстеження і відповідають критеріям допуску до донорства рис.3.13.

Рисунок 3.13 – Сторінка перегляду списку донорів банку

	Під час додавання нового донора заповнюється спеціальна форма, де вказується його повне ім’я, електронна пошта, дата народження, стать, резус-фактор та контактний номер телефону 3.14.




Рисунок 3.14 – Сторінка реєстрації нового донора у системі

Працівник банку крові також має доступ до переліку поставок та детальної інформації щодо кожної з них. Для створення нової поставки необхідно натиснути на червону кнопку у правому верхньому куті сторінки, після чого відкривається вікно з формою, у якій вказується назва поставки. Додана поставка з’являється у загальному переліку. Кожна поставка має у правому куті три кнопки: перегляд деталей, додавання пакету крові та обробка поставки. При перегляді деталей відкривається список усіх пакетів крові, що входять до цієї поставки. При обробці поставки система автоматично перетворює пакети крові на компоненти та заносить їх до інвентаря банку крові 3.15 – 3.17.

Рисунок 3.15 – Сторінка перегляду поставок крові до банку

Рисунок 3.16 – Вікно перегляду деталей про поставку крові до банку

Рисунок 3.17 – Вікно додавання пакету крові до певної поставки


3.4	   Захист даних у веб частині програмної системи


Захист даних у веб частині програмної системи є критично важливим елементом загальної архітектури безпеки, оскільки саме через веб-інтерфейс відбувається більшість взаємодій кінцевих користувачів із системою. У реалізації системи використовуються сучасні підходи до аутентифікації та авторизації, зокрема через застосування JWT-токенів (JSON Web Tokens), які дозволяють безпечно передавати інформацію про користувача між клієнтом та сервером у зашифрованому вигляді.
Процес входу в систему реалізований у вигляді окремого HTTP-запиту до бекенду, де на основі введених облікових даних відбувається перевірка користувача та генерація токена. У разі успішної аутентифікації система надає користувачу JWT, який використовується для підтвердження особи при подальших запитах. Цей токен зберігається на стороні клієнта (у сесії або cookie) та включається до заголовків наступних запитів, що дозволяє уникнути необхідності повторної перевірки кожного запиту окремо. Водночас забезпечується централізований контроль доступу до функціоналу системи відповідно до ролі користувача.
Особливу увагу приділено захисту персональних даних, таких як електронна пошта, роль, ідентифікатор користувача та інші, які передаються через зашифровані канали зв’язку за допомогою HTTP. Для попередження несанкціонованого доступу до окремих частин інтерфейсу системи впроваджено механізм перевірки прав доступу на стороні клієнта, де користувачу надається лише той функціонал, що відповідає його ролі в системі (наприклад, адміністратор банку крові, працівник лікарні тощо). Таким чином, навіть якщо користувач намагається вручну звернутись до забороненого ресурсу, система ідентифікує невідповідність прав і не виконує запит.
Застосування фреймворку Django для побудови веб-частини системи також відіграє важливу роль у забезпеченні безпеки. Django має вбудовані механізми захисту від поширених веб-загроз, зокрема XSS (Cross-Site Scripting), CSRF (Cross-Site Request Forgery), SQL-ін’єкцій та інших. Для цього всі шаблони автоматично екранізують змінні, а механізм CSRF-захисту вбудований у всі форми та HTTP-запити. Крім того, Django дозволяє гнучко керувати сесіями користувачів, а також швидко впроваджувати зміни в політику безпеки через конфігураційні файли.
Загалом, комбінація захисту через JWT-токени, HTTP-протокол, перевірку ролей користувача та потужні вбудовані засоби безпеки Django дозволяє реалізувати надійний рівень захисту в веб-частині програмної системи, мінімізуючи ризики витоку або несанкціонованого доступу до чутливої інформації.





3.5	    Висновки


У межах лабораторної роботи було розроблено веб частину програмної системи, архітектура якої ґрунтується на класичній клієнт-серверній моделі. Клієнтська частина відповідає за взаємодію користувача з інтерфейсом, тоді як серверна частина обробляє запити, виконує бізнес-логіку та взаємодіє з базою даних. Компоненти системи реалізовані з дотриманням принципів модульності та розділення відповідальностей, що забезпечує гнучкість, масштабованість і спрощене тестування.
У веб частині програмної системи використовуються сучасні програмні технології. На стороні клієнта застосовано фреймворк Django, який поєднує засоби рендерингу інтерфейсу, маршрутизації запитів і вбудовані механізми захисту. Django забезпечує зручну роботу з шаблонами, формами, сесіями та автентифікацією. Для комунікації з сервером використовується HTTP-протокол, а передача даних виконується у форматі JSON, що сприяє зручній взаємодії з бекендом. Система передбачає взаємодію з RESTful API, який обробляє запити, пов’язані з логуванням, перевіркою прав доступу, зміною паролів, реєстрацією та іншими діями.
Бізнес-логіка у веб частині охоплює такі ключові функції, як автентифікація користувачів, розмежування прав доступу відповідно до ролей, управління сесіями, перегляд та редагування персональних даних, а також можливість змінювати пароль користувача. Залежно від ролі (наприклад, адміністратор, співробітник тощо), користувачу доступні різні функціональні можливості, що забезпечує персоналізований доступ до системи.






ДОДАТОК А
Хронологічний опис відео

Відеозапис доповіді на YouTube: https://youtu.be/YDgPR6zuO9Y
Хронологічний опис відео
00:00 Вступ 
00:10 Розділ 2 Завдання до лабораторної роботи 
00:57 Розділ 3.1 Архітектура веб-частини програмної системи 
06:23 Розділ 3.2 Бізнес-логіка веб-частини програмної системи 
12:00 Розділ 3.3 Опис інтерфейсу веб-клієнту програмної системи 
15:30 Розділ 3.4 Захист даних у веб частині програмної системи 
17:17 Демонстрація роботи веб частини програмної системи

Посилання на файл з кодом в GitHub репозиторії: https://github.com/NureRubanenkoMariia/apz-pzpi-22-7-rubanenko-mariia/tree/main/Lab3/apz-pzpi-22-7-rubanenko-mariia-lab3/frontend



ДОДОТОК Б



1    import json
2    import requests
3    from django.shortcuts import render, redirect
4    from django.contrib import messages
5    from django.conf import settings
6    
7    def login(request):
8        if request.method == 'POST':
9            email = request.POST.get('email')
10           password = request.POST.get('password')
11           
12           data = {
13               "name": "",
14               "email": email,
15               "password": password
16           }
17           
18           try:
19               response = requests.post(
20                   f'{settings.BACKEND_API_URL}/login',
21                   headers={'Content-Type': 'application/json'},
22                   data=json.dumps(data)
23               )
24               
25               if response.status_code == 200:
26                   user_response = requests.get(
27                       f'{settings.BACKEND_API_URL}/user/email',
28                       params={'email': email}
29                   )
30                   
31                   if user_response.status_code == 200:
32                       user_data = user_response.json()
33                       
34                       allowed_roles = [1, 2, 4]
35                       if user_data['role_id'] not in allowed_roles:
36                           messages.error(request, 'Access denied. You do not have permission to log in.')
37                           return render(request, 'main/login.html', {
38                               'error': 'Access denied',
39                               'email': email
40                           })
41                       
42                       roles_response = requests.get(f'{settings.BACKEND_API_URL}/roles')
43                       if roles_response.status_code == 200:
44                           roles = roles_response.json()
45                           role_mapping = {role['role_id']: role['name'] for role in roles}
46                           role_name = role_mapping.get(user_data['role_id'], 'Unknown Role')
47                       else:
48                           role_name = 'Unknown Role'
49                       
50                       request.session['user'] = {
51                           'name': user_data['name'],
52                           'email': user_data['email'],
53                           'role_id': user_data['role_id'],
54                           'role_name': role_name,
55                           'user_id': user_data['user_id']
56                       }
57                       return redirect('home')
58                   else:
59                       messages.error(request, 'Error fetching user details')
60               elif response.status_code == 401:
61                   return render(request, 'main/login.html', {
62                       'error': 'Invalid email or password',
63                       'email': email
64                   })
65               else:
66                   return render(request, 'main/login.html', {
67                       'error': 'Login failed. Please try again.',
68                       'email': email
69                   })
70           except requests.exceptions.RequestException as e:
71               messages.error(request, f'Connection error: {str(e)}')
72               
73       return render(request, 'main/login.html')
74   
75   def register(request):
76       if request.method == 'POST':
77           return redirect('login')
78       return render(request, 'main/register.html')
79   
80   def logout(request):
81       if 'user' in request.session:
82           del request.session['user']
83       return redirect('login')
84   
85   def change_password(request):
86       if request.method == 'POST':
87           user = request.session.get('user')
88           if not user:
89               return redirect('login')
90   
91           old_password = request.POST.get('current_password')
92           new_password = request.POST.get('new_password')
93           confirm_password = request.POST.get('confirm_password')
94   
95           if new_password != confirm_password:
96               messages.error(request, 'New passwords do not match')
97               return redirect('user_details')
98   
99           try:
100              response = requests.post(
101                  f'{settings.BACKEND_API_URL}/user/change-password/{user["user_id"]}',
102                  headers={'Content-Type': 'application/json'},
103                  json={
104                      'old_password': old_password,
105                      'new_password': new_password
106                  }
107              )
108  
109              if response.status_code == 200:
110                  messages.success(request, 'Password changed successfully')
111              else:
112                  messages.error(request, 'Failed to change password. Please check your current password.')
113  
114          except requests.exceptions.RequestException:
115              messages.error(request, 'Connection error. Please try again later.')
116  
117          return redirect('user_details')
118  
119      return redirect('user_details')


