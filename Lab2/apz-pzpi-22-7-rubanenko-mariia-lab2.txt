Міністерство освіти і науки України
Харківський національний  університет радіоелектроніки


Кафедра програмної інженерії 



Лабораторна робота №2
 з дисципліни: «Архітектура програмного забезпечення» 
на тему: «Розробка програмної архітектури, створення та відлагодження програмного коду серверної частини програмної системи»






Виконала
ст. гр. ПЗПІ-22-7
Рубаненко Марія Сергіївна
03 травня 2025 р.
Перевірив
ст. викл. Сокорчук І. П.





Харків 2025
1 ІСТОРІЯ ЗМІН

Таблиця 1.1 відображає зміни, внесені до документа.
Таблиця 1.1 - Історія змін
№	Дата	Версія звіту	Опис змін та виправлень
1	03.05.2025	0.1	Розділ «Історія змін» було додано до документа
2	03.05.2025	0.1	Розділ «Завдання до лабораторної роботи» було додано до документа
3	03.05.2025	0.1	Розділ «Опис виконаної роботи» було додано до документа
4	03.05.2025	0.1	Розділ «Висновки» було додано до документа
5	03.05.2025	0.1	У документ включено «Додаток А» з посиланням на відеоролик
6	03.05.2025	0.1	У документ включено «Додаток Б» 














2 ЗАВДАННЯ


Метою лабораторної роботи є розробка і документування серверної частини програмної системи, а також архітектурних рішень, що лежать в її основі. У межах роботи необхідно сформувати загальне уявлення про архітектуру системи, детально описати будову її серверних компонентів, а також структуру бази даних, яка забезпечує збереження та обробку даних. Особливу увагу слід приділити прийнятим інженерним рішенням, що стосуються як технологічного стеку, так і логіки взаємодії між компонентами.
У звіті має бути представлена UML-діаграма розгортання, яка відображає апаратно-програмне розміщення компонентів системи, а також UML-діаграма прецедентів, що демонструє взаємодію користувачів з системою. Обов’язковим є також побудова ER-моделі даних, яка відображає структуру сутностей та їхні зв’язки у базі даних. Окрім цього, обирається додатково одна з діаграм: компонент, пакетів, взаємодії, діяльності або станів — залежно від особливостей реалізованої системи.
У рамках виконання завдання потрібно надати текстовий опис архітектури програмної системи та її серверної частини, з поясненням використаних технологій і методів. Має бути описано специфікацію REST або іншого обраного методу взаємодії між програмними компонентами, а також наведено методи обробки даних, реалізовані з використанням математичних та алгоритмічних підходів. Додатково необхідно розкрити підхід до інтерналізації (багатомовної підтримки) та етапи функціонального тестування, проведені для перевірки працездатності серверної частини.





3	ОПИС ВИКОНАНОЇ РОБОТИ


3.1	  Моделювання функціоналу інформаційної системи


Діаграма моделює функціонал інформаційної системи для управління банком крові рис.3.1. Система орієнтована на координацію дій між кількома групами користувачів: власниками банків крові, працівниками, донорами, лікарнями, транспортувальниками. 

Рисунок 3.1 – UML -діаграма прецедентів інформаційної системи «Банк крові»

Всі групи користувачів мають чітко визначені ролі та завдання, які підтримуються через взаємодію з системою:

а)	власник банку крові:
1)	реєстрація працівників банку у системі;
2)	доступ до статистики (поставки, переробка, транспортування);
3)	управління роботою банку крові
б)	працівник банку крові
1)	обробка запитів від лікарень на постачання крові;
2)	обробка постачань крові (підготовка крові до транспортування або зберігання);
3)	призначення транспортувальників для виконання запитів на доставку.
в)	працівник лікарні
1)	реєстрація лікарні як установи в системі
2)	надсилання запитів на постачання крові із зазначенням вимог (група крові, об’єм тощо);
3)	отримання доставленої крові після обробки запитів.
г)	донор
1)	реєстрація в системі з можливістю заповнити медичну карту;
2)	управління профілем (оновлення контактних чи медичних даних):
3)	перегляд історії донорства;
4)	ознайомлення з рекомендаціями щодо харчування та активності після здачі крові;
д)	транспортувальник
1)	отримання завдань на транспортування крові;
2)	забезпечення перевезення крові в спеціальних умовах;
3)	контроль обладнання (холодильників для крові);
е)	працівник технічного обслуговування
1)	технічне обслуговування та оновлення системи;
2)	усунення технічних несправностей.

Щодо функціональних прецедентів, система управління банком крові починається з процесу реєстрації в системі, що є спільним для всіх типів користувачів. Кожен актор, який хоче отримати доступ до функціоналу, повинен створити обліковий запис. Процес реєстрації відрізняється залежно від ролі: донори під час реєстрації заповнюють медичну карту, працівники лікарень вказують тип установи, а працівників банку крові та транспортувальників реєструє власник банку крові. Після реєстрації кожен користувач проходить через процес автентифікації, здійснюючи вхід у систему за допомогою логіна і пароля.
Однією з ключових функцій системи є управління запитами на постачання крові, які надходять від лікарень. Працівники лікарень заповнюють анкету, де вказують специфічні вимоги, такі як група крові, обсяг та терміни доставки. Ці запити обробляються працівниками банку крові, які аналізують їх на предмет відповідності запасам крові та призначають транспортувальників для виконання запиту. Після цього кров готується до транспортування, і відповідальність переходить до транспортувальників.
Окрім обробки запитів, працівники банку крові займаються обробкою постачань крові, що включає її підготовку до зберігання, перевірку якості та документування. Паралельно транспортувальники забезпечують транспортування крові, дотримуючись усіх вимог щодо умов перевезення, таких як контроль температури і вологості за допомогою спеціальних датчиків. У разі відхилень від норм, система повідомляє відповідальних осіб для вжиття необхідних заходів.
Донори, які є джерелом поповнення запасів крові, мають доступ до своїх профілів, де вони можуть переглядати історію донорства, що включає дати здачі крові, обсяг та інші деталі. 
Для власника банку крові передбачений окремий функціонал – він має можливість переглядати статистику щодо роботи системи. Це включає інформацію про кількість оброблених запитів, виконаних постачань, стан запасів крові.


3.2	   Розробка бізнес логіку серверної частини програмної системи


Для розробки бізнес-логіки серверної частини програмної системи була 
використана UML-діаграма діяльності системи «Банк крові» рис.3.2. UML-діаграма діяльності є графічним поданням процесів і взаємодій, що відображають алгоритми виконання задач у системі. Вона наочно демонструє послідовність операцій, залежності між етапами, а також умови переходу між ними. Використання такої діаграми значно полегшує планування та реалізацію бізнес-логіки, дозволяє структуровано описати взаємодію користувачів із системою відповідно до їхніх ролей, а також врахувати всі можливі сценарії роботи. Завдяки цьому забезпечується точність і логічна цілісність функціоналу, що реалізується на серверній частині.


Рисунок 3.2 – UML -діаграма діяльності системи «Банк крові»

Процес починається з початкової точки, позначеної чорним кругом, що символізує старт виконання операцій для користувача або системи. Користувач переходить до входу в систему, де перевіряється умова: чи є він новим користувачем. Якщо користувач новий, він переходить до процесу реєстрації, а якщо ні, отримує доступ до основного функціоналу, відповідного до своєї ролі.
На етапі реєстрації користувач обирає свою роль у системі. Доступні три ролі: власник банку крові, який реєструє власну установу; працівник лікарні, який подає заявки на кров; або донор, фізична особа, що готова здавати кров. Для кожної ролі передбачено заповнення відповідної форми. Власник банку крові реєструється як установа, працівник лікарні — як представник медичної установи, а донор — за стандартною реєстраційною процедурою. Після успішної реєстрації обліковий запис створюється, і користувач може переходити до виконання завдань.
Після входу в систему або завершення реєстрації користувач взаємодіє із системою залежно від своєї ролі.
Донор має змогу редагувати особистий профіль, змінюючи персональні дані, переглядати рекомендації щодо здоров’я, включно з підготовкою до здачі крові та післяпроцедурним доглядом, а також отримувати доступ до історії донорства, де відображаються всі попередні запити та внески.
Працівник лікарні може подавати заявки на кров, заповнюючи відповідну форму. Система перевіряє банки крові, які відповідають умовам заявки. Якщо знайдено банки, що задовольняють потреби, працівник лікарні надсилає запит до обраного банку. У випадку, якщо лише один банк може задовольнити запит, система надає інформацію про нього, зокрема його можливості покриття заявки.
Функціонал працівників банку поділяється на два рівні: власник банку та працівники банку.
Власник банку реєструє нових співробітників, надаючи їм відповідні ролі, та переглядає статистику щодо постачань крові та доставок до лікарень.
Працівники банку приймають заявки від лікарень. Після перевірки наявності потрібного обсягу крові приймається рішення щодо заявки. Працівники також вносять дані про постачання у систему, контролюють кількість крові у банку та строки її придатності, оформлюють документи для доставки крові до лікарень та призначають транспортувальників.
Транспортувальник приймає заявку на доставку крові до лікарні, налаштовує датчики холодильників для контролю температури та інших параметрів, важливих для належного зберігання крові, і здійснює доставку.
Після виконання всіх завдань користувач завершує свою діяльність у системі, що відображається чорним кругом із обвідкою, який символізує логічне завершення процесу.



3.3	  Опис загальної архітектури програмної системи

Програмна система для управління банками крові побудована за клієнт-серверною архітектурою з чітким поділом на фронтенд, мобільну частину та сервер. Веб-клієнт реалізовано з використанням Django, що забезпечує динамічне формування веб-інтерфейсу для користувачів (адміністраторів, лікарів тощо). Мобільний додаток створено за допомогою Kotlin для платформи Android, що забезпечує доступ донорів до функціоналу з мобільного пристрою.
Серверна частина реалізована на Flask — легкому веб-фреймворку для Python. Вона відповідає за обробку запитів, роботу з базою даних, автентифікацію, валідацію та підготовку відповідей у форматі JSON. Обмін даними між клієнтськими застосунками і сервером відбувається через REST API.
Вся система використовує реляційну базу даних, структура якої описана у вигляді ER-моделі. Взаємодія з базою реалізована через ORM-бібліотеку SQLAlchemy. Також передбачена можливість створення резервних копій бази даних, що забезпечує стабільність роботи і захист даних. Додатково система включає обробку сенсорних IoT-даних та може бути інтегрована з державними медичними системами відповідно до українського законодавства і міжнародних стандартів.


3.4	 Архітектура серверної частини програмної системи


Серверна частина програмної системи реалізована з використанням мікрофреймворку Flask, що забезпечує легкість створення REST API та дозволяє гнучко налаштовувати маршрутизацію, обробку запитів і відповіді клієнту. В основі архітектури лежить модель MVC (Model-View-Controller), що дозволяє розділити логіку програми на окремі компоненти. Модельна частина реалізована за допомогою ORM SQLAlchemy — одного з найпопулярніших інструментів у Python для роботи з базами даних. Вона дозволяє відображати таблиці бази даних у вигляді класів Python, а також працювати з даними за допомогою об’єктно-орієнтованого підходу. Така реалізація спрощує підтримку та розвиток проєкту, дозволяючи уникнути використання сирих SQL-запитів.
У структурі проєкту також передбачені окремі класи для серіалізації та валідації даних, які формують відповіді у форматі JSON перед передачею на фронтенд. Це дозволяє централізовано здійснювати перевірку даних, автоматично формувати структуру відповіді та додатково збагачувати її допоміжною інформацією. Крім цього, реалізовано централізовану обробку помилок, яка дозволяє виявляти виключення та повертати стандартизовані повідомлення з відповідними кодами статусів, що значно полегшує відлагодження клієнтської частини.
Логіка програми структурована у вигляді окремих модулів, кожен з яких відповідає за свій напрямок — маршрути, сервіси, моделі, обробники помилок тощо. Для кожного функціонального блоку створені окремі файли з маршрутами, які обробляють відповідні HTTP-запити та викликають відповідні методи. Аутентифікація реалізована на основі JWT-токенів, що забезпечує захист API та дозволяє ідентифікувати користувачів. В системі передбачено також окремий клас для реалізації резервного копіювання бази даних, що дозволяє створювати бекапи у визначеному форматі.
Загальна архітектура відповідає принципам чистої архітектури, де розмежовано рівні взаємодії з базою даних, бізнес-логіки та презентаційного шару. Впроваджено також деякі патерни проєктування, серед яких найпомітнішими є Repository, що забезпечує абстракцію взаємодії з базою даних, Singleton, який гарантує єдиний екземпляр для роботи з налаштуваннями та підключеннями, та Factory, що полегшує створення об'єктів певного типу з інкапсуляцією логіки створення. Додатково використовується сервісний рівень, що відділяє логіку обробки даних від контролерів і підвищує читаність та масштабованість проєкту.
Серверна частина також підтримує інтерналізацію, реалізовану через конфігураційні файли, що дозволяє адаптувати систему до кількох мовних середовищ і забезпечує локалізовану взаємодію з користувачами. Такий підхід до побудови архітектури дозволяє ефективно масштабувати проєкт, розширювати його функціональність, інтегрувати зовнішні сервіси або мікросервіси, а також здійснювати тестування окремих компонентів без втручання в основну логіку.


3.5  Створення ER діаграми даних


Перед початком розробки бази даних для системи управління банком крові було створено ER-діаграму для спрощення моделювання структури даних рис.3.3. 
На ER-діаграмі показано взаємозв’язок між наступними сутностями:
	Банк крові (id, назва, email, розташування, контактний телефон);
	Центр донорства крові (id, назва);
	Холодильник для крові (id, назва, місткість);
	Група крові (id, назва, резус-фактор);
	Запаси крові (id, id банку крові, id групи крові, id компонента, дата створення, термін придатності);
	Компонент крові (id, назва, об’єм одного пакету, умови зберігання, термін придатності в днях);
	Запит крові (id, статус, дата запиту, id лікарні, id банку крові);
	Компоненти запиту (id запиту, id компонента, кількість);
	Транзакції з кров’ю (id, тип транзакції, кількість, дата операції);
	Транспортування крові (id, id банку крові, статус);
	Донор (id, id групи крові, контактний телефон);
	Сеанс донорства (id, id донора, кількість крові, дата сеансу);
	Лікарня (id, назва, контактний телефон);
	Поставка крові (id, id центру донорства, id банку крові, дата);
	Деталі поставки (id поставки, id групи крові, id компонента, дата створення, термін придатності);
	Сенсори транспортування (id транспортування, температура, стан).
Для забезпечення цілісності зв'язків створено наступні відношення:
	між Банк крові та Запаси крові: зв’язок один-до-багатьох (кожен банк має власні запаси крові);
	між Група крові та Донор: зв’язок один-до-багатьох (одна група крові може бути у багатьох донорів);
	між Запит крові та Компоненти запиту: зв’язок один-до-багатьох (кожен запит може включати кілька компонентів);
	між Поставка крові та Деталі поставки: зв’язок один-до-багатьох (кожна поставка може містити кілька пакетів крові);
Аналізуючи структуру бази даних, можна зробити висновок, що більшість зв’язків є "один до багатьох", що забезпечує оптимальну організацію даних та їхню інтеграцію між сутностями.


Рисунок 3.3 – ER-діаграма інформаційної системи «Банк крові»

Розглянемо детальніше деякі зв’язки:
	Зв’язок між Запаси крові та Компонент крові: запаси містять конкретні компоненти крові, кожен із яких має визначений об’єм і термін придатності.
	Зв’язок між Запит крові та Лікарня: кожна лікарня може подавати багато запитів на кров.
	Зв’язок між Донор та Сеанс донорства: кожен донор може брати участь у багатьох сеансах донорства, але кожен сеанс прив’язаний до конкретного донора.
Ця структура забезпечує гнучкість та можливість розширення системи, зокрема для додавання нових функціональностей, таких як аналіз ефективності поставок або автоматизація повідомлень для донорів.


3.6	Побудова логічної моделі бази даних на основі ER-діаграми


		Процес проектування логічної моделі бази даних «Система управління банком крові» передбачає вибір реляційної моделі, що є оптимальним рішенням для предметної області. Ця модель найкраще відповідає потребам зберігання, обробки та аналізу структурованих даних, таких як інформація про донорів, запаси крові, запити лікарень, транспортування крові та інші аспекти системи рис.3.4.
Після ретельного аналізу ER-діаграми, було розроблено схему реляційної бази даних, що складається з сімнадцяти таблиць. Для іменування цих таблиць та їх атрибутів була використана англійська мова. Нижче наведено довідник англомовних назв атрибутів:
а)	table «blood_bank» – таблиця «Банк крові» має такі атрибути:
1)	blood_bank_id – ідентифікатор банку крові;first_name – ім’я злочинця;
2)	name – назва банку крові;
3)	email – електронна пошта банку;
4)	location – місце розташування банку крові;
5)	contact_number – контактний номер телефону
6)	user_id – ідентифікатор користувача, власника банку.

б)	table «blood_donation_center» – таблиця «Центр донорства крові» має такі атрибути:
1)	blood_donation_center_id – ідентифікатор центру донорства;
2)	name – назва центру донорства крові.

в)	table «blood_fridge» – таблиця «Холодильник для крові» має такі атрибути:
1)	blood_fridge_id – ідентифікатор холодильника;
2)	name – назва холодильника;
3)	capacity_ml – місткість холодильника в мілілітрах.

г)	table «blood_group» – таблиця «Групи крові» має такі атрибути:
1)	blood_group_id – ідентифікатор групи крові;
2)	name – назва групи крові;
3)	rhesus_factor – резус-фактор.

д)	table «blood_inventory» – таблиця «Інвентар крові» має такі атрибути:
1)	blood_inventory_id – ідентифікатор інвентарної одиниці;
2)	blood_bank_id – ідентифікатор банку крові, де знаходиться одиниця;
3)	blood_group_id – ідентифікатор групи крові;
4)	blood_part_id – ідентифікатор компоненту крові;
5)	creation_date – дата створення одиниці;
6)	expiry_date – дата закінчення терміну придатності.
е)	table «blood_part» –таблиця «Компоненти крові» має такі атрибути:
1)	blood_part_id – ідентифікатор компоненту крові;
2)	name – назва компоненту;
3)	volume_per_bag_ml – обсяг однієї одиниці компоненту в мілілітрах;
4)	storage_conditions – умови зберігання;
5)	shelf_life_days – термін придатності в днях.

ж)	table «blood_part_request» –таблиця «Запити на компоненти крові» має такі атрибути:
1)	request_blood_id – ідентифікатор запиту крові; crime_type – тип злочину.
2)	blood_part_id – ідентифікатор компоненту крові;
3)	quantity – кількість одиниць.

з)	table «blood_request» – таблиця «Запити крові» має такі атрибути:
1)	request_blood_id – ідентифікатор запиту;
2)	status – статус запиту;
3)	request_date – дата створення запиту;
4)	hospital_id – ідентифікатор лікарні, яка подала запит;
5)	blood_bank_id – ідентифікатор банку крові, що виконує запит.
и)	table «hospital» – таблиця «Лікарня» має такі атрибути:
1)	     request_blood_id – ідентифікатор запиту;
2)	     hospital_id – ідентифікатор лікарні;
3)	     name – назва лікарні;
4)	     location – місце розташування лікарні;
5)	     contact_number – контактний номер лікарні.

к)	table «donor» – таблиця «Донор» має такі атрибути
1)	     donor_id – ідентифікатор донора;
2)	     name – ім'я донора;
3)	     blood_group_id – ідентифікатор групи крові донора;
4)	     email – електронна пошта донора;
5)	      contact_number – контактний номер телефону донора;
6)	     sex – стать донора;
7)	     age – вік донора;
8)	     date_of_birth – дата народження донора.

л)	table «blood_transaction» – таблиця «Транзакції крові» має такі атрибути:
1)	     blood_transaction_id – ідентифікатор транзакції;
2)	     transaction_type – тип транзакції;
3)	     supply_id – ідентифікатор постачання;
4)	     request_blood_id – ідентифікатор запиту на кров;
5)	     blood_part_id – ідентифікатор компонента крові;
6)	     quantity – кількість;
7)	     transaction_date – дата транзакції;
8)	     blood_bank_id – ідентифікатор банку крові.

м)	table «blood_transport» – таблиця «Перевезення крові» має такі атрибути: 
1)	     blood_transport_id – ідентифікатор транспорту;
2)	     bank_id – ідентифікатор банку крові;
3)	     start_time – час початку транспортування;
4)	     end_time – час завершення транспортування;
5)	     user_id – ідентифікатор користувача;
6)	     request_blood_id – ідентифікатор запиту на кров;
7)	     status – статус транспортування.

н)	table «user» – таблиця «Користувачі» має такі атрибути: 
1)	     user_id – ідентифікатор користувача;
2)	     name – ім'я користувача;
3)	     email – електронна пошта;
4)	     password – пароль;
5)	     role_id – ідентифікатор ролі користувача.

о)	table «user_role» – таблиця «Ролі користувачів» має такі атрибути:
1)	     role_id – ідентифікатор ролі;
2)	     name – назва ролі.

п)	table «transport_sensor» – таблиця «Датчики транспортування» має такі атрибути:
1)	     blood_fridge_id – ідентифікатор холодильника для крові;
2)	     blood_transport_id – ідентифікатор транспортування крові;
3)	     temperature – температура в транспорті;
4)	     time_stamp – позначка часу;
5)	     status – статус датчика;
6)	     transport_sensor_id – ідентифікатор датчика транспортування.

р)	table «supply» – таблиця «Постачання» має такі атрибути:
1)	     supply_id – ідентифікатор постачання;
2)	     blood_bank_id – ідентифікатор банку крові;
3)	     blood_donation_center_id – ідентифікатор центру здачі крові;
4)	     supply_date – дата постачання.

с)	table «supply_details» – таблиця «Деталі постачання» має такі атрибути:
1)	     supply_details_id – ідентифікатор деталей постачання;
2)	     supply_id – ідентифікатор постачання;
3)	     blood_group_id – ідентифікатор групи крові;
4)	     creation_date – дата створення;
5)	     expiry_date – дата закінчення терміну придатності.


Рисунок 3.4 –  Схема бази даних «Банк крові»

3.7	Математичні методи обробки користувацьких даних у серверній частині

У серверній частині системи обробка користувацьких даних реалізується через поєднання структурованих підходів до збереження, валідації та фільтрації даних. Основним інструментом для доступу до даних є ORM-бібліотека SQLAlchemy, яка дозволяє трансформувати введені користувачем дані в об’єкти Python-класів та зберігати їх у базі даних без прямого використання SQL-запитів. Кожен клас відображає таблицю в базі, а кожен атрибут класу — колонку таблиці. При цьому під час додавання нових даних відбувається перевірка на унікальність, заповнення обов’язкових полів, відповідність типів — усе це реалізовано як частина вбудованих механізмів перевірки цілісності даних.
Також застосовуються програмні методи для логічної валідації, наприклад, перевірка правильності введеного email. У разі потреби дані користувача фільтруються та групуються за певними критеріями, наприклад, при вибірці об’єктів, пов’язаних з певним користувачем або періодом часу. Ці обчислення виконуються або на рівні SQL-запитів, або за допомогою відповідних методів Python.
У системі реалізовано механізми обробки транзакцій, які гарантують узгодженість даних під час виконання послідовності операцій (створення, оновлення, видалення). Наприклад, при створенні нового запису про лікарню система перевіряє наявність зв’язку з існуючим користувачем і лише після проходження всіх перевірок виконується запис до бази. У разі помилки система автоматично скасовує зміну, що забезпечує математичну узгодженість бази.


3.8	Серверна обробка та збереження користувацьких даних

Обробка даних користувача на сервері включає декілька важливих етапів: перевірку, валідацію, трансформацію, фільтрацію та збереження. У системі ці операції реалізовані з використанням інструментів мови Python, а також бібліотеки SQLAlchemy, яка виконує роль посередника між логікою застосунку та базою даних.
На етапі надходження даних із клієнтської частини система виконує попередню перевірку значень, які користувач надав через інтерфейс. Наприклад, перевіряється коректність формату електронної пошти, унікальність імені користувача, відповідність паролю мінімальним вимогам безпеки. Для цього використовуються регулярні вирази та логічні конструкції.
Після валідації дані проходять через логіку бізнес-рівня — наприклад, автоматичне присвоєння ролей новим користувачам, розрахунок прив’язок до певної лікарні або групи. 
Наступним кроком є збереження інформації в базі даних. Тут застосовуються методи транзакційної обробки: всі зміни даних виконуються в межах сесії, яка гарантує цілісність — або всі зміни будуть успішно збережені, або не буде збережено нічого (у разі помилки).
Для прикладу розглянемо модель з таблицею Hospital, яка зберігає дані про лікарні.

1 from sqlalchemy import Column, Integer, String, ForeignKey
2 from sqlalchemy.orm import relationship, backref
3 from app import db
4 class Hospital(db.Model):
5 __tablename__ = "hospital"
6
7 hospital_id = Column(Integer, primary_key=True)
8 name = Column(String(255), nullable=False)
9 email = Column(String(255), nullable=False, unique=True)
10 location = Column(String(255), nullable=False)
11 contact_number = Column(String(50), nullable=False)
12 user_id = Column(Integer, ForeignKey('user.user_id'), nullable=False)
13
14 user = relationship("User", backref=backref("hospitals", lazy=True))
15 def __repr__(self):
16 return f"<Hospital {self.name}>"

Цей клас відповідає таблиці hospital у базі даних, а зв’язок user_id використовується для прив’язки до іншої таблиці user (зв’язок "багато до одного"). Це забезпечує зручний доступ до об’єктів, пов’язаних із записами в базі даних.
Для виконання CRUD-операцій були створені статичні методи, які ілюструють переваги використання SQLAlchemy. Ось приклад такої функції для створення у системі нової лікарні.

1    @staticmethod
2    def create_hospital(data):
3        try:
4            new_hospital = Hospital(
5                name=data.get("name"),
6                email=data.get("email"),
7                location=data.get("location"),
8                contact_number=data.get("contact_number"),
9                user_id=data.get("user_id"),
10            )
11            db.session.add(new_hospital)
12            db.session.commit()
13            return {"message": "Hospital created successfully"}, 201
14        except Exception as e:
15            db.session.rollback()
16            return ErrorHandler.handle_error(
17                e, message="Failed to create hospital", status_code=500
18            )


3.9	Розробка REST API для взаємодії серверної частини з клієнтами.


Для розробки взаємодії серверної частини з клієнтами було обрано REST, це архітектурний стиль для створення API, який використовує протокол HTTP для обміну даними між клієнтом і сервером. Основною ідеєю REST є забезпечення уніфікованого інтерфейсу для взаємодії з ресурсами, які можна ідентифікувати через унікальні URL-адреси. Ресурси в REST API є різними об'єктами або даними, такими як користувачі, замовлення або доставки, і з ними можна працювати через різні HTTP-методи.
У процесі розробки API було застосовано принципи REST, що включають використання стандартних HTTP-методів: GET для отримання даних, POST для створення нових ресурсів, PUT для оновлення існуючих, і DELETE для видалення ресурсів рис.3.5. 

 
Рисунок  3.5 – Приклад використання стандартних HTTP-методів

Кожен запит API супроводжується відповідним статусом HTTP, що вказує на успішність або помилку операції, наприклад, статуси 200 OK, 404 Not Found, або 500 Internal Server Error рис.3.6 – 3.7. 
 
Рисунок 3.6  – Приклад отримання статусу 200 

 
Рисунок  3.7 – Приклад отримання статусу 404

Розроблений API організовано навколо ресурсів, для яких визначено унікальні ендпоінти для виконання CRUD-операцій. Наприклад, ендпоінт GET /blood-groups дозволяє отримати список груп крові рис.3.8, а POST /create-hospital— дозволяє зареєструвати нову лікарню у системі рис.3.9. 

 
Рисунок  3.8 – Приклад GET запиту

 
Рисунок  3.9 – Приклад POST запиту

Також було забезпечено відловлювання та обробку помилок, які можуть бути отримані під час введення користувачами некоректних даних, наприклад спроба отримати дані неіснуючої лікарні буде супроводжуватися статусом 404 і відповідним повідомленням рис.3.10.
 
Рисунок  3.10 – Приклад обробки помилки

Для захисту інформації реалізовано механізми аутентифікації та авторизації, що включають використання токенів для перевірки прав доступу. 
Для захисту інформації в API була реалізована система аутентифікації та авторизації, яка використовує JWT (JSON Web Tokens). JWT є стандартом для передачі інформації між двома сторонами в компактному та захищеному вигляді. Це дозволяє забезпечити безпеку, оскільки всі дані в токені підписуються за допомогою секретного ключа, що дозволяє перевіряти цілісність даних і їх автентичність.
Для розробки була використана бібліотека, така як Flask-JWT-Extended, яка полегшує інтеграцію цієї технології в додаток. Бібліотека дозволяє створювати та перевіряти JWT токени для аутентифікації користувачів, а також для авторизації доступу до захищених ендпоінтів API.
Процес аутентифікації з використанням JWT в даному випадку складається з кількох етапів. Спочатку, коли користувач намагається увійти в систему, він надсилає свої облікові дані (наприклад, ім’я користувача та пароль) через HTTP-запит до ендпоінта аутентифікації. Якщо дані правильні, сервер генерує JWT токен, що містить необхідну інформацію про користувача  та певні права доступу, і відправляє цей токен назад користувачеві рис.3.11.

 
Рисунок 3.11 – Приклад входу у систему і видачі токена доступу

Згодом, кожен наступний запит до захищеного ресурсу клієнт повинен надсилати цей токен у заголовку HTTP-запиту, в заголовку Authorization у форматі Bearer рис.3.12. Сервер на основі токена перевіряє його достовірність. 
За допомого Flask-JWT-Extended також налаштовано термін дії токена, що буде вимагати у користувача знову залогінитися через деякий час.

 
Рисунок 3.12 – Приклад передачі токена та успішного доступу до захищеного ресурсу


3.10     Математичні методи обробки користувацьких даних для реалізації бізнес логіки програмної системи. 


Для реалізації серверної частини використовується архітектура REST API, яка дозволяє взаємодіяти з клієнтськими додатками через стандартизовані HTTP-запити. Основна логіка зосереджена на обробці запитів, перевірці даних, виконанні операцій із базою даних та поверненні відповідей у форматі JSON. Бізнес-логіка реалізована у вигляді набору модулів, кожен з яких відповідає за певний функціонал системи. 
Обробка заявок на кров додаток А, серверна частина перевіряє доступність необхідної крові у банках, сортує банки за відповідністю умовам запиту, та автоматично обирає найкращий варіант.
	Функція find_best_matching_bank реалізує бізнес-логіку для автоматичної обробки заявок лікарень на кров. Вона вирішує завдання визначення банку крові, який найкраще покриває потреби заявки, аналізуючи запаси крові у всіх доступних банках і обираючи оптимальний варіант. Якщо запасів у жодному банку не вистачає, система пропонує банк, що максимально покриває об’єм заявки, оновлюючи в заявку.
Функція починає з отримання списку заявок на кров для конкретного запиту, ідентифікованого через request_blood_id. Для кожної позиції заявки формується карта необхідних компонентів крові у форматі blood_part_id_blood_group_id, де ключем є тип і група крові, а значенням — кількість, потрібна лікарні. Далі система аналізує запаси кожного банку крові. Запаси завантажуються через модель BloodInventory, і для кожного банку формується карта доступних компонентів крові з урахуванням їх кількості. Ці дані дозволяють оцінити відповідність кожного банку вимогам заявки.
Визначення покриття здійснюється шляхом порівняння необхідної кількості кожного компонента із запасами у банку. Якщо банк має достатню кількість певного компонента, ця кількість зараховується до покриття matched_quantities. Якщо компоненту не вистачає, система реєструє його нестачу missing_quantities і враховує лише доступну кількість у покритті. Загальне покриття банку обчислюється як сума всіх зарахованих одиниць, що відповідають заявці.
Після цього система порівнює всі банки за загальним покриттям і обирає банк із максимальною кількістю задоволених одиниць. Якщо обраний банк повністю покриває всі потреби заявки, результат повертається без подальших змін. У випадку, якщо деяких компонентів не вистачає, система зменшує кількість у заявці на недоотримані обсяги і фіксує ці зміни в базі даних.
Формула, яка використовується в коді для оцінки покриття кожного банку крові відповідно до заявки, базується на сумуванні зарахованих обсягів компонентів крові, що задовольняють вимоги заявки. 
Кількість компонентів крові певного типу k, необхідна лікарні це required_quantities[k]. Кількість компонентів крові певного типу k, доступна в банку це available_quantities[k]. Кількість крові, яку банк може надати для цього компонента це min(available_quantities[k],required_quantities[k]).
Результат обчислень дозволяє оцінити, наскільки кожен банк може задовольнити заявку лікарні. Після цього функція обирає банк із максимальним покриттям, де total_matchedb  — загальний обсяг крові, яку банк b може надати.
 
Якщо банк, який обрано, не може повністю задовольнити заявку, система автоматично зменшує обсяги в заявці на недоотримані компоненти і зберігає ці зміни. Таким чином, функція оптимізує процес вибору та дозволяє максимально ефективно використовувати доступні ресурси.
Реалізація також передбачає обробку помилок. У разі виникнення виключення всі незавершені транзакції скасовуються, щоб уникнути некоректного стану даних, а користувач отримує відповідне повідомлення.
Таким чином, функція забезпечує автоматизацію процесу обробки заявок, ефективно використовуючи доступні ресурси банків крові, і дозволяє лікарням отримати найбільш відповідні варіанти поставки.
Обробка поставок крові додаток Б, серверна частина приймає поставку та вносить її перероблений вигляд у базу. 
Функція process_supply_to_inventory реалізує логіку обробки поставок цільної крові в банк. Її головною метою є автоматичний розрахунок компонентів крові (еритроцити, плазма, тромбоцити), які виділяються з кожної одиниці крові, та їх додавання до загального обліку банку крові. Крім цього, для кожного компонента система фіксує термін придатності, залежно від дати його створення та нормативного строку зберігання.
Функція починає роботу з отримання даних про поставку через її унікальний ідентифікатор supply_id. Далі отримуються деталі поставки (наприклад, група крові, дата постачання) і список усіх типів компонентів крові, які можуть бути виділені з цільної крові.
Для кожного запису в деталях поставки система обробляє компоненти. У циклі для кожного типу компонентів розраховується дата закінчення терміну придатності: до дати постачання додається кількість днів, допустимих для зберігання цього компонента. Потім створюється новий запис у таблиці BloodInventory, який включає ідентифікатор банку крові, тип компонента, групу крові, дату створення та термін придатності. Цей запис додається до бази даних.
Після завершення процесу додавання компонентів система також створює запис у таблиці транзакцій BloodTransaction. У записі вказується тип транзакції ("incoming"), кількість кожного компонента, його тип, ідентифікатор поставки та банк крові. Це дозволяє підтримувати прозорий облік усіх надходжень і змін у запасах крові.
Реалізація враховує можливість виникнення помилок у процесі роботи. Якщо під час виконання функції трапляється виключення, усі незавершені транзакції скасовуються за допомогою db.session.rollback(), що гарантує цілісність даних. Таким чином, функція забезпечує автоматизацію процесу обробки поставок і підтримує точний облік усіх змін у запасах банку крові.
Обробка заявок на кров банком додаток В, серверна частина приймає заявку на постачання крові до лікарні певним банком та вносить відповідні змани у кількість запасів банку. 
Функція process_request реалізує обробку банком крові заявки, яка надходить від лікарні. Основні завдання цієї функції — виконання доставки необхідної крові та компонентів, автоматичне оновлення даних у таблицях обліку запасів і транзакцій, а також контроль наявності достатньої кількості необхідних компонентів у банку крові. Функція отримує заявку через її ідентифікатор request_blood_id. Якщо така заявка відсутня, система повертає повідомлення про помилку. Якщо заявка знайдена, їй встановлюється статус inprogress, і вона прив'язується до конкретного банку крові blood_bank_id. 
Для кожного запиту компонентів крові (наприклад, еритроцити або плазма) визначається потрібна кількість quantity_to_remove і тип компонента blood_part_id. Далі функція шукає записи про доступні компоненти у таблиці BloodInventory, що відповідають конкретному банку крові. Записи сортуються за датою створення, щоб забезпечити використання найстаріших компонентів (стратегія FIFO — "першим прийшло, першим пішло").
Кожен запис про компонент видаляється з бази даних доти, доки не буде виконано потрібну кількість. Якщо під час видалення виявиться, що необхідної кількості компонентів немає, транзакція скасовується (db.session.rollback()), а функція повертає повідомлення про нестачу крові з зазначенням бракуючої кількості.
Для кожного видаленого компонента створюється запис у таблиці BloodTransaction із вказанням типу транзакції (outgoing), ідентифікатора заявки, типу компоненту, кількості, що була видалена, та банку крові.
Після успішного видалення всіх необхідних компонентів функція зберігає зміни в базі даних і повертає повідомлення про успішну обробку заявки. 
Функція автоматично оновлює стан запасів банку крові і створює записи про кожну транзакцію. Це дозволяє забезпечити прозорий облік змін у системі та мінімізує ризики помилок через людський фактор.


3.11	Специфікація розробленого API


Маршрути, створені для роботи з банками крові рис. 3.13 – 3.16:
	маршрут /banks не приймає вхідних параметрів, повертає перелік усіх банків, зареєстрованих у системі, та інформацію про кожен з них.
	маршрут /bank/<int:blood_bank_id> приймає blood_bank_id (ідентифікатор банку) як вхідний параметр, повертає детальну інформацію про конкретний банк крові.
	маршрут /create-bank приймає вхідні параметри для створення нового банку крові, такі як назва банку, електронна адреса, локація, контактний телефон, ідентифікатор власника. Повертає повідомлення про успішне створення банку крові.
	маршрут /update-bank/<int:blood_bank_id> приймає blood_bank_id (ідентифікатор банку) та оновлену інформацію про банк крові для редагування. Повертає повідомлення про успішне оновлення даних банку крові.

 
Рисунок 3.13 – Приклад вхідних і вихідних параметрів маршруту /banks

 
Рисунок 3.14 – Приклад вхідних і вихідних параметрів маршруту /bank/<int:blood_bank_id>

 
Рисунок 3.15 – Приклад вхідних і вихідних параметрів маршруту /create-bank

 
Рисунок 3.16 – Приклад вхідних і вихідних параметрів маршруту /update-bank/<int:blood_bank_id>

Маршрути, створені для роботи з лікарнями рис. 3.17 – 3.20:
	маршрут /hospitals: не приймає вхідних параметрів, повертає перелік усіх лікарень, зареєстрованих у системі, та інформацію про кожну з них.
	маршрут /hospital/<int:hospital_id>: приймає hospital_id (ідентифікатор лікарні) як вхідний параметр, повертає детальну інформацію про конкретну лікарню.
	маршрут /create-hospital: приймає вхідні параметри для створення нової лікарні, такі як назва лікарні, електронна адреса, локація, контактний телефон, ідентифікатор відповідальної особи. Повертає повідомлення про успішне створення лікарні.
	маршрут /update-hospital/<int:hospital_id>: приймає hospital_id (ідентифікатор лікарні) та оновлену інформацію про лікарню для редагування. Повертає повідомлення про успішне оновлення даних лікарні.


Рисунок 3.17 – Приклад вхідних і вихідних параметрів маршруту /hospitals

 
Рисунок 3.18 – Приклад вхідних і вихідних параметрів маршруту /hospital/<int:hospital_id>

 
Рисунок 3.19 – Приклад вхідних і вихідних параметрів маршруту /create-hospital

 
Рисунок 3.20 – Приклад вхідних і вихідних параметрів маршруту /update-hospital/<int:hospital_id>

Маршрути, створені для роботи переліком груп крові рис. 3.21 – 3.24:
	маршрут / blood-groups не приймає вхідних параметрів, повертає перелік усіх існуючих груп крові та резусів;
	маршрут /blood-group/<int:blood_group_id> приймає blood_group_id (ідентифікатор групи крові) як вхідний параметр, повертає детальну інформацію про групу крові. 

 
Рисунок 3.21 – Приклад вхідних і вихідних параметрів маршруту /blood-groups

 
Рисунок 3.22 – Приклад вхідних і вихідних параметрів маршруту /blood-group/<int:blood_group_id>

Маршрути, створені для роботи переліком частин крові 1.22–1.23:
	маршрут /blood-parts не приймає вхідних параметрів, повертає перелік усіх існуючих груп крові та резусів;
	маршрут /blood-part/<int:blood_part_id> приймає blood_part_id (ідентифікатор частини крові) як вхідний параметр, повертає детальну інформацію про частину крові.

 
Рисунок 3.23 – Приклад вхідних і вихідних параметрів маршруту /blood-parts

Рисунок 3.24 – Приклад вхідних і вихідних параметрів маршруту /blood-part/<int:blood_part_id>

Маршрути, створені для роботи з донорами 3.25 – 3.30:
	маршрут /donors  не приймає вхідних параметрів, повертає перелік усіх донорів, зареєстрованих у системі, та інформацію про кожного з них.
	маршрут /donor/<int:user_id> приймає user_id (ідентифікатор користувача) як вхідний параметр, повертає детальну інформацію про конкретного користувача.
	маршрут /create-donor приймає вхідні параметри для занесення у систему інформації для нового донора, такі як група крові, стать, рік народження. Повертає повідомлення про успішне створення запису.
	маршрут /update-donor/<int:donor_id> приймає donor_id (ідентифікатор донора) та оновлену інформацію про донора для редагування. Повертає повідомлення про успішне оновлення даних донора.
	маршрут /create-donation-session приймає вхідні параметри для занесення у систему інформації про нову здачу крові конкретного донора. Повертає повідомлення про успішне створення запису.
	маршрут /donation-session/<int:donor_id> приймає donor_id (ідентифікатор донора) та видає список усіх його донорський сесій.


 
Рисунок 3.25 – Приклад вхідних і вихідних параметрів маршруту /donors  

 
Рисунок 3.26 – Приклад вхідних і вихідних параметрів маршруту /donor/<int:user_id>


 
Рисунок 3.27 – Приклад вхідних і вихідних параметрів маршруту /create-donor

 
Рисунок 3.28 – Приклад вхідних і вихідних параметрів маршруту /update-donor/<int:donor_id>

 
Рисунок 3.29 – Приклад вхідних і вихідних параметрів маршруту /create-donation-session

 
Рисунок 3.30 – Приклад вхідних і вихідних параметрів маршруту /donation-session/<int:donor_id>

Маршрути, створені для роботи з поставками рис.3.31 – 3.38:
	маршрут /supplies/<int:blood_bank_id>  приймає ідентифікатор банку, повертає перелік усіх постачань, зареєстрованих у системі для заданого банку, та інформацію про кожне з них.
	маршрут /supply/<int:supply_id> приймає supply_id (ідентифікатор постачання) як вхідний параметр, повертає детальну інформацію про конкретне постачання.
	маршрут /create-supply приймає дані про нове постачання, зокрема ідентифікатори відповідних об'єктів та дату постачання. Повертає повідомлення про успішне створення постачання.
	маршрут /update-supply/<int:supply_id> приймає supply_id (ідентифікатор постачання) та оновлену інформацію. повертає повідомлення про успішне оновлення даних постачання.
	маршрут /supply-details/<int:supply_id>  приймає ідентифікатор поставки, повертає перелік усіх деталей постачання та інформацію про кожну з них для заданої поставки.
	маршрут /supply-detail/<int:supply_details_id> приймає supply_details_id (ідентифікатор деталей постачання) як вхідний параметр, повертає детальну інформацію про конкретну деталь постачання.
	маршрут /create-supply-detail приймає дані для створення нової деталі постачання, зокрема інформацію про групу крові, дату створення та термін придатності. повертає повідомлення про успішне створення деталі. 
	маршрут /update-supply-detail/<int:supply_details_id> приймає supply_details_id (ідентифікатор деталей постачання) та оновлену інформацію. повертає повідомлення про успішне оновлення деталей постачання.

 
Рисунок 3.31 – Приклад вхідних і вихідних параметрів маршруту /supplies/<int:blood_bank_id>

 
Рисунок 3.32 – Приклад вхідних і вихідних параметрів маршруту 
/create-supply 

 
Рисунок 3.33 – Приклад вхідних і вихідних параметрів маршруту /supplies/<int:blood_bank_id>

 

Рисунок 3.34 – Приклад вхідних і вихідних параметрів маршруту /update-supply/<int:supply_id

 
Рисунок 3.35 – Приклад вхідних і вихідних параметрів маршруту /create-supply-detail
 
Рисунок 3.36 – Приклад вхідних і вихідних параметрів маршруту /supply-detail/<int:supply_details_id>

 
Рисунок 3.37 – Приклад вхідних і вихідних параметрів маршруту /supply-details/<int:supply_id>

 
Рисунок 3.38 – Приклад вхідних і вихідних параметрів маршруту /update-supply-detail/<int:supply_details_id>

Маршрути, створені для роботи з заявками на постачання рис.3.39 – 3.44:
	маршрут /blood-requests/<int:blood_bank_id>, приймає ідентифікатор банку і  повертає перелік усіх запитів на кров, зареєстрованих у системі які прийняв даний банк, разом з відповідною інформацією про кожен запит.
	маршрут /blood-request/<int:request_blood_id> приймає request_blood_id (ідентифікатор запиту на кров) як вхідний параметр, повертає детальну інформацію про конкретний запит.
	маршрут /create-blood-request приймає дані для створення нового запиту на кров, включаючи інформацію про тип крові, необхідну кількість та інші пов'язані дані. повертає повідомлення про успішне створення запиту.
	маршрут /update-blood-request/<int:request_blood_id> приймає request_blood_id (ідентифікатор запиту на кров) та оновлену інформацію про запит. повертає повідомлення про успішне оновлення запиту.
	маршрут /blood-part-requests/<int:request_blood_id> приймає request_blood_id як вхідний параметр, повертає список усіх запитів на окремі компоненти крові, що стосуються конкретного запиту.
	маршрут /blood-part-request/<int:request_blood_id>/<int:blood_part_id> приймає request_blood_id (ідентифікатор запиту на кров) та blood_part_id (ідентифікатор компонента крові) як вхідні параметри, повертає інформацію про конкретний запит на компонент крові в межах запиту.
	маршрут /create-blood-part-request приймає дані для створення запиту на окремий компонент крові, включаючи інформацію про компонент, його кількість та інші пов'язані дані. повертає повідомлення про успішне створення запиту.

 
Рисунок 3.39 – Приклад вхідних і вихідних параметрів маршруту /create-blood-request

 
Рисунок 3.40 – Приклад вхідних і вихідних параметрів маршруту /blood-requests/<int:blood_bank_id>

 
Рисунок 3.41 – Приклад вхідних і вихідних параметрів маршруту /blood-request/<int:request_blood_id>

 
Рисунок 3.42 – Приклад вхідних і вихідних параметрів маршруту /create-blood-part-request

 
Рисунок 3.43 – Приклад вхідних і вихідних параметрів маршруту /blood-part-request/<int:request_blood_id>/<int:blood_part_id>

 

Рисунок 3.44 – Приклад вхідних і вихідних параметрів маршруту /blood-part-requests/<int:request_blood_id>

Маршрути, створені для роботи з транспортуванням крові рис.3.45 – 1.47:
	маршрут /blood-transports/<int:blood_bank_id> приймає blood_bank_id (ідентифікатор банку крові) як вхідний параметр, повертає список усіх транспортувань крові, пов'язаних із зазначеним банком крові. інформація містить деталі про кожне транспортування, включаючи дати та обсяги перевезеної крові.
	маршрут /blood-transport/<int:blood_transport_id> приймає blood_transport_id (ідентифікатор транспортування) як вхідний параметр, повертає детальну інформацію про конкретне транспортування крові.
	маршрут /create-blood-transport приймає дані для створення нового запису про транспортування крові, включаючи інформацію про банк крові, пункт відправлення, пункт призначення, кількість крові та дату транспортування. повертає повідомлення про успішне створення запису.
	маршрут /update-blood-transport/<int:blood_transport_id> приймає blood_transport_id (ідентифікатор транспортування) та оновлені дані про транспортування, такі як місце призначення, дата чи обсяг крові. повертає повідомлення про успішне оновлення запису.

Рисунок 3.45 – Приклад вхідних і вихідних параметрів маршруту /blood-transports/<int:blood_bank_id>

Рисунок 3.46 – Приклад вхідних і вихідних параметрів маршруту /blood-transport/<int:blood_transport_id>

Рисунок 3.47 – Приклад вхідних і вихідних параметрів маршруту /create-blood-transport 


Рисунок 3.48 – Приклад вхідних і вихідних параметрів маршруту /update-blood-transport/<int:blood_transport_id>

Маршрути створені для управління холодильниками для зберігання крові рис. 3.49 – 3.51:
	маршрут /blood-fridges не приймає вхідних параметрів, повертає список усіх холодильників, зареєстрованих у системі. 
	маршрут /blood-fridge/<int:blood_fridge_id> приймає blood_fridge_id (ідентифікатор холодильника) як вхідний параметр, повертає детальну інформацію про конкретний холодильник для крові. ця інформація може включати обсяг, температуру, розташування та інші характеристики.
	маршрут /create-blood-fridge приймає дані для створення нового холодильника, такі як місцезнаходження, максимальна місткість та початковий стан. повертає повідомлення про успішне створення запису.

Рисунок 3.49 – Приклад вхідних і вихідних параметрів маршруту /blood-fridges

 
Рисунок 3.50 – Приклад вхідних і вихідних параметрів маршруту /blood-fridge/<int:blood_fridge_id>

Рисунок 3.51 – Приклад вхідних і вихідних параметрів маршруту /create-blood-fridge

Маршрути створені для управління сенсорами в холодильниках рис.3.52 –3.53:
	маршрут /transport-sensor/<int:blood_transport_id> /<int:blood_fridge_id> приймає два вхідні параметри — blood_transport_id (ідентифікатор транспортного засобу) та blood_fridge_id (ідентифікатор холодильника). повертає список усіх сенсорів, пов'язаних із вказаним транспортним засобом або холодильником. інформація може включати показники сенсорів, такі як температура, вологість або стан.
	маршрут /create-transport-sensor приймає дані для створення нового сенсора, такі як тип сенсора, його характеристики та прив'язка до конкретного транспортного засобу чи холодильника. повертає повідомлення про успішне створення сенсора.
Рисунок 3.52 – Приклад вхідних і вихідних параметрів маршруту /transport-sensor/<int:blood_transport_id>/<int:blood_fridge_id>

Рисунок 3.53 – Приклад вхідних і вихідних параметрів маршруту /create-transport-sensor


Маршрути створені для управління запасами крові та процесами постачання і заявок рис.3.54 – 3.62:
	маршрут /process-supply/<int:supply_id> приймає ідентифікатор поставки (supply_id) як вхідний параметр. цей маршрут виконується після того, як працівник банку завершив облік поставки та вніс усі пакети крові у систему. після виклику маршруту кров автоматично розподіляється на складові (лейкоцити, тромбоцити та плазму), які додаються до системи. також у таблиці транзакцій з'являється запис про прибуття певної кількості крові до банку.
	маршрут /blood-inventory/<int:blood_bank_id> приймає ідентифікатор банку крові (blood_bank_id) як вхідний параметр. повертає інформацію про запаси крові у вказаному банку, включаючи кількість і типи компонентів крові.
	маршрут /process-request/<int:blood_bank_id>/<int:request_blood_id> приймає два вхідні параметри — ідентифікатор банку крові (blood_bank_id) та ідентифікатор заявки на кров (request_blood_id), цей маршрут символізує прийняття банком заявки на постачання крові до лікарні, після його виклику статус заявки змінюється на inprogress, і в таблиці транзакцій автоматично створюється запис про кількість запасів крові, які будуть доставлені до лікарні, також автоматично зменшується кількість запасів крові у відповідному банку.
	маршрут /transactions/<int:blood_bank_id>/<start_date>/<end_date> приймає ідентифікатор банку крові (blood_bank_id) та часовий інтервал (start_date і end_date) як вхідні параметри, повертає список транзакцій, здійснених у вказаному банку крові за вибраний період, включаючи типи та кількість крові, що надійшли чи були використані.
	маршрут /find-bank/<int:request_blood_id> приймає ідентифіктор запиту на доставку крові як вхідний параметр, повертає список банків, які повністю або частково покривають вимоги доставки.
	маршрут /daily-report/<int:blood_bank_id> приймає ідентифікатор банку крові (blood_bank_id), повертає звіт по кількості частин крові певної групи та перелік пакеті з частинами крові у яких закінчується термін придатності.
	маршрут /delete-inventory/<int:blood_inventory_id> приймає ідентифікатор запису у таблиці інвентару, повертає повідомлення про успішне його видалення.


Рисунок 3.54 – Приклад вхідних і вихідних параметрів маршруту /process-request/<int:blood_bank_id>/<int:request_blood_id>


Рисунок 3.55 – Приклад вхідних і вихідних параметрів маршруту /blood-inventory/<int:blood_bank_id>

Рисунок 3.56 – Приклад вхідних і вихідних параметрів маршруту /process-supply/<int:supply_id>


Рисунок 3.57 – Приклад вхідних і вихідних параметрів маршруту /transactions/<int:blood_bank_id>/<start_date>/<end_date>

Рисунок 3.58 – Приклад вхідних і вихідних параметрів маршруту /find-bank/<int:request_blood_id> 

Рисунок 3.59 – Приклад вхідних і вихідних параметрів маршруту / daily-report/<int:blood_bank_id> 

Рисунок 3.60 – Приклад вхідних і вихідних параметрів маршруту  /delete-inventory/<int:blood_inventory_id>

Маршрут створений для адміністративного управління системою рис. 1.60  /backup-database, його виконання створює бекап бази (резервну копію) рис.1.61, та зберігає у вказаній користувачем у конфігурації папці. 
Рисунок 3.61 – Приклад вхідних і вихідних параметрів маршруту  /backup-database 

Рисунок 3.62 – Створений бекап бази


3.12	Етапи функціонального тестування створеної серверної частини

Функціональне тестування серверної частини системи банку крові проводилося з метою перевірки правильності реалізації ключових функцій та відповідності логіки роботи заявленим вимогам. Тестування здійснювалося у спеціально підготовленому середовищі з окремою тестовою базою даних, що дозволяло уникати втручання в реальні дані та гарантувати чистоту результатів перевірок.
Основна увага приділялася перевірці роботи REST API, яке реалізує взаємодію клієнтів із сервером. У рамках тестування перевірялися маршрути, відповідальні за автентифікацію, авторизацію, а також створення, редагування, перегляд і видалення ресурсів системи, таких як інформація про донорів, лікарні та запаси крові.
Тестування виконувалося вручну за допомогою інструменту Postman, який дозволив швидко створювати різні сценарії запитів. Для кожного маршруту перевірялася обробка запитів з коректними даними, де очікуваною відповіддю були статус-коди 200 (успішне виконання) або 201 (створення ресурсу). Також перевірялися ситуації, у яких клієнт надсилає некоректні або неповні дані — у таких випадках система повинна повертати відповідні помилки з кодами 400 (Bad Request) або 422 (Unprocessable Entity). Важливою частиною тестування була перевірка обробки неавторизованих запитів, для яких очікувався статус 401 (Unauthorized), що гарантує захист ресурсів від несанкціонованого доступу.
Окремо перевірялася поведінка системи при відсутності обов’язкових полів у запитах, некоректних типах даних або порушенні унікальності записів. Усі відповіді серверної частини аналізувалися не лише з точки зору коректності статус-коду, а й на відповідність формату повідомлень про помилки та дотримання загального стилю API.
Під час тестування також оцінювалась надійність механізмів транзакцій та обробки виключень: у разі виникнення помилок система повинна була здійснювати відкат змін і повертати зрозуміле повідомлення для користувача або розробника.
Результати тестування підтвердили стабільну та передбачувану роботу серверної частини. Виявлені недоліки були незначними й оперативно усунуті на етапі розробки.


3.13	Етапи розгортання системи


Діаграма розгортання відображає архітектуру інформаційної системи для керування банком з кров’ю, реалізованої на основі Flask-додатку з використанням SQLAlchemy ORM та взаємодією з базою даних через інтерфейс ODBC.

Рисунок 3.63 – UML діаграма розгортання

У центрі розташовано сервер додатка, який є ядром системи. На ньому працює Flask-додаток, що обробляє HTTP-запити та реалізує логіку доступу до бази даних за допомогою ORM SQLAlchemy. Також тут розміщено модуль автентифікації на основі JWT і логіку резервного копіювання.
До сервера додатка підключено кілька клієнтів. Веб-клієнт, розгорнутий на фронтенд-сервері, обмінюється даними з сервером через HTTP, забезпечуючи інтерфейс користувача. Окремо передбачено тестовий клієнт API — Postman, який також здійснює HTTP-запити для перевірки працездатності та тестування API.
Система інтегрується з IoT-емулятором холодильників з кров’ю, який моделює фізичні пристрої, надсилаючи дані через HTTP до сервера додатка. Це забезпечує імітацію температурного моніторингу та інших параметрів у реальному часі.
З боку зберігання даних сервер додатка взаємодіє із СУБД, яка містить SQL-движок та файли бази даних, що фізично розміщені на диску. Підключення реалізовано через ODBC, що забезпечує незалежність від конкретного типу СУБД. Для резервного копіювання даних SQL-движок має доступ до локальної директорії бекапів через файлову систему, куди зберігаються резервні копії бази даних.
Розгортання програмної системи передбачає кілька послідовних кроків, які забезпечують правильну підготовку серверної частини та емулятора IoT. 
На початку слід завантажити архів із програмним кодом проєкту та розпакувати його у відповідну директорію. Після цього необхідно відкрити термінал або командний рядок, перейти до кореневої директорії проєкту за допомогою команди cd.
	Для ізоляції залежностей рекомендується створити віртуальне середовище за допомогою команди python -m venv venv. Ця команда створює директорію venv, що містить локальну копію Python і необхідні бібліотеки. Віртуальне середовище активується на Windows командою venv\Scripts\activate, на macOS/Linux командою source venv/bin/activate. 
	Після активації середовища необхідно встановити всі залежності, вказані у файлі requirements.txt командою pip install -r requirements.txt. 
	Для роботи системи створюється файл .env у кореневій директорії проєкту, який має містити такі параметри:

1   SECRET_KEY="згенероване_значення"
2   DATABASE_URL="посилання_на_базу"
3   JWT_SECRET_KEY="згенероване_значення"
4   DATABASE_NAME = "ім’я_бази"
5   BACKUP_DIR = "шлях_до_папки_де_зберігатимуться_бекапи"
6   FLASK_APP="run.py"

Секретні ключі SECRET_KEY і JWT_SECRET_KEY можна згенерувати у Python-консолі за допомогою команди python -c "import secrets; print(secrets.token_hex(32))". Параметр DATABASE_URL налаштовується відповідно до конфігурації сервера Microsoft SQL Server.
Параметр BACKUP_DIR потрібний для налаштування резервного копіювання бази даних. Вказується шлях до папки з бекапами, назва файлу бекапу буде складатися з імені бази, слова бекап та часової мітки.
Для запуску серверу Flask виконується команда flask run Після запуску сервер стає доступним за адресою http://127.0.0.1:5000. 
Архів із емулятором IoT розпаковується в окрему директорію. Для налаштування необхідно перейти до цієї директорії у терміналі та створити віртуальне середовище, активувати його та встановити залежності, як це робилося раніше. Емулятор IoT запускається командою python main.py.
Розгортання скрипта бази даних у Microsoft SQL Server передбачає виконання декількох етапів. Перш за все, відкривається Microsoft SQL Server Management Studio (SSMS) та підключається до потрібного інстансу сервера, вказуючи дані для аутентифікації.
Далі завантажується скрипт бази даних. Це виконується через меню File, де потрібно обрати Open → File і вказує шлях до скрипта. У скрипті потрібно змінити FILENAME рис 1.1. 

Рисунок 1.1 –Налаштування FILENAME у скрипті бази даних Blood bank

 Для запуску скрипта натискається кнопка Execute або використовується клавіша F5. Після завершення виконання потрібно перевірити успішність операції, переглядаючи повідомлення в нижньому вікні. Потім здійснюється візуальна перевірка створених таблиць через панель Object Explorer. 
	Для забезпечення надійності та ефективності роботи зі скриптами бази даних потрібно дотримуватися таких правил, а саме перед виконанням будь-якого скрипта, який вносить зміни у вже існуючу базу даних, необхідно створити резервну копію, це дозволить уникнути втрати даних у разі помилок під час виконання. Слід перевірити, що версія SQL Server відповідає тій, для якої створено скрипт. Невідповідність може призвести до помилок або некоректної роботи бази даних.


3.14	Висновки


	У ході роботи було розроблено будову програмної системи «Банк крові», яка включає моделювання процесів взаємодії користувачів та компонентів системи за допомогою UML-діаграм. Було також створено ER-діаграми для структурування даних та візуалізації їх взаємозв'язків. Розроблено функціональність для роботи з базою даних, що забезпечує збереження та ефективну обробку інформації про кровоздачі, запити лікарень та інші важливі процеси. Система інтегрує автоматизовані засоби контролю, забезпечуючи надійність і безпеку під час роботи з кров'ю, що підвищує її ефективність у задоволенні потреб медичних закладів.




ДОДАТОК А
Хронологічний опис відео

Відеозапис доповіді на YouTube: https://youtu.be/FJkUHOP6PKU

Хронологічний опис відео 
00:00 Вступ
00:25 Розділ 2 Завдання до лабораторної роботи 
03:08 Розділ 3.3 Опис загальної архітектури програмної системи 
04:00 Розділ 3.4 Архітектура серверної частини програмної системи 
08:28 Розділ 3.7 Математичні методи обробки користувацьких даних у серверній частині 
09:27 Розділ 3.8 Серверна обробка та збереження користувацьких даних 
11:23 Розділ 3.10 Математичні методи обробки користувацьких даних для реалізації бізнес логіки програмної системи 
12:45 Розділ 3.12 Етапи функціонального тестування створеної серверної частини 
15:10 Розділ 3.13 Етапи розгортання системи 
19:50 Висновки












ДОДАТОК Б


1    @staticmethod
2    def find_best_matching_bank(request_blood_id):
3        try:
4            blood_part_requests = BloodPartRequest.query.filter_by(request_blood_id=request_blood_id).all()
5
6            required_quantities = {
7                f"{req.blood_part_id}_{req.blood_group_id}": req.quantity
8                for req in blood_part_requests
9            }
10
11            bank_coverage = {}
12            blood_banks = BloodBank.query.all()
13            for bank in blood_banks:
14                bank_id = bank.blood_bank_id
15                inventory = BloodInventory.query.filter_by(blood_bank_id=bank_id).all()
16                available_quantities = {}
17
18                for inv in inventory:
19                    key = f"{inv.blood_part_id}_{inv.blood_group_id}"
20                    available_quantities[key] = available_quantities.get(key, 0) + 1
21
22                matched_quantities = {}
23                missing_quantities = {}
24                for key, req_qty in required_quantities.items():
25                    available_qty = available_quantities.get(key, 0)
26                    if available_qty >= req_qty:
27                        matched_quantities[key] = req_qty
28                    else:
29                        matched_quantities[key] = available_qty
30                        missing_quantities[key] = req_qty - available_qty
31
32                bank_coverage[bank_id] = {
33                    "matched_quantities": matched_quantities,
34                    "missing_quantities": missing_quantities,
35                    "total_matched": sum(matched_quantities.values()),
36                }
37
38            best_bank_id, best_bank_data = max(bank_coverage.items(), key=lambda x: x[1]["total_matched"])
39
40            if not best_bank_data["missing_quantities"]:
41                return BloodInventoryResponse.response_find_best_matching_bank(
42                    best_bank_id,
43                    best_bank_data["total_matched"],
44                    best_bank_data["matched_quantities"],
45                    None
46                )
47
48            for blood_part_key, missing_qty in best_bank_data["missing_quantities"].items():
49                blood_part_id, blood_group_id = map(int, blood_part_key.split("_"))
50                request_record = db.session.query(BloodPartRequest).filter_by(
51                    request_blood_id=request_blood_id,
52                    blood_part_id=blood_part_id,
53                    blood_group_id=blood_group_id
54                ).first()
55
56                if request_record:
57                    request_record.quantity -= missing_qty
58
59            db.session.commit()
60
61            return BloodInventoryResponse.response_find_best_matching_bank(
62                best_bank_id,
63                best_bank_data["total_matched"],
64                best_bank_data["matched_quantities"],
65                best_bank_data["missing_quantities"]
66            )
67
68        except Exception as e:
69            db.session.rollback()
70            return ErrorHandler.handle_error(e, message="Failed to find the best matching bank", status_code=500)















ДОДАТОК В


1    @staticmethod
2    def process_supply_to_inventory(supply_id):
3        try:
4            supply = Supply.query.get(supply_id)
5            blood_bank_id = supply.blood_bank_id
6            supply_details_records = SupplyDetails.get_details_by_supply_id(supply_id)
7            blood_parts = BloodPart.query.all()
8            total_blood_inventory_records = 0
9
10            for record in supply_details_records:
11                for part in blood_parts:
12                    expiry_date = record.creation_date + timedelta(days=part.shelf_life_days)
13
14                    new_inventory = BloodInventory(
15                        blood_bank_id=record.supply.blood_bank_id,
16                        blood_part_id=part.blood_part_id,
17                        creation_date=record.creation_date,
18                        expiry_date=expiry_date,
19                        blood_group_id=record.blood_group_id
20                    )
21                    db.session.add(new_inventory)
22                    db.session.commit()
23
24                total_blood_inventory_records += 1
25
26            for part in blood_parts:
27                quantity = total_blood_inventory_records
28                BloodTransaction.create_transaction(
29                    transaction_type="incoming",
30                    supply_id=supply_id,
31                    blood_part_id=part.blood_part_id,
32                    quantity=quantity,
33                    blood_bank_id=blood_bank_id,
34                )
35
36            return {"message": f"Successfully processed {total_blood_inventory_records * len(blood_parts)} blood inventory records"}, 200
37
38        except Exception as e:
39            db.session.rollback()
40            return ErrorHandler.handle_error(e, message="Failed to processed blood", status_code=500)






ДОДАТОК Г

1    @staticmethod
2    def process_request(blood_bank_id, request_blood_id):
3        try:
4            blood_parts = BloodPart.query.all()
5            blood_part_requests = BloodPartRequest.query.filter_by(request_blood_id=request_blood_id).all()
6            total_blood_inventory_records = 0
7
8            request = BloodRequest.query.get(request_blood_id)
9            if not request:
10                return ErrorHandler.handle_error(None, message="Blood request not found", status_code=404)
11
12            request.blood_bank_id = blood_bank_id
13            request.status = "inprogress"
14            db.session.commit()
15
16            for blood_part_request in blood_part_requests:
17                quantity_to_remove = blood_part_request.quantity
18                blood_part_id = blood_part_request.blood_part_id
19                blood_group_id = blood_part_request.blood_group_id
20
21                inventory_records = db.session.query(BloodInventory).filter(
22                    BloodInventory.blood_bank_id == blood_bank_id,
23                    BloodInventory.blood_part_id == blood_part_id,
24                    BloodInventory.blood_group_id == blood_group_id,
25                ).order_by(BloodInventory.creation_date.asc()).all()
26
27                removed_records_count = 0
28
29                for inventory in inventory_records:
30                    if quantity_to_remove <= 0:
31                        break
32
33                    db.session.delete(inventory)
34                    quantity_to_remove -= 1
35                    removed_records_count += 1
36
37                if quantity_to_remove > 0:
38                    db.session.rollback()
39                    return ErrorHandler.handle_error(
40                        None,
41                        message=f"Not enough blood inventory for blood part ID {blood_part_id}. Missing {quantity_to_remove} units.",
42                        status_code=400
43                    )
44
45                BloodTransaction.create_transaction(
46                    transaction_type="outgoing",
47                    request_blood_id=request_blood_id,
48                    blood_part_id=blood_part_id,
49                    quantity=removed_records_count,
50                    blood_bank_id=blood_bank_id,
51                )
52
53                total_blood_inventory_records += removed_records_count
54
55            db.session.commit()
56
57            return {"message": "Blood request processed successfully"}, 200
58        except Exception as e:
59            db.session.rollback()
60            return ErrorHandler.handle_error(e, message="Failed to process blood request", status_code=500)



